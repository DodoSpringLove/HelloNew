/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.uiautomator.core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeoutException;

import android.accessibilityservice.AccessibilityService;
import android.app.UiAutomation;
import android.app.UiAutomation.AccessibilityEventFilter;
import android.graphics.Point;
import android.os.RemoteException;
import android.os.SystemClock;
import android.util.Log;
import android.view.InputDevice;
import android.view.InputEvent;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerCoords;
import android.view.MotionEvent.PointerProperties;
import android.view.accessibility.AccessibilityEvent;

import com.android.internal.util.Predicate;

/**
 * The InteractionProvider is responsible for injecting user events such as
 * touch events (includes swipes) and text key events into the system. To do so,
 * all it needs to know about are coordinates of the touch events and text for
 * the text input events. The InteractionController performs no synchronization.
 * It will fire touch and text input events as fast as it receives them. All
 * idle synchronization is performed prior to querying the hierarchy. See
 * {@link QueryController}
 */
class InteractionController {

	private static final String LOG_TAG = InteractionController.class
			.getSimpleName();

	private static final boolean DEBUG = Log.isLoggable(LOG_TAG, Log.DEBUG);

	private final KeyCharacterMap mKeyCharacterMap = KeyCharacterMap
			.load(KeyCharacterMap.VIRTUAL_KEYBOARD);

	private final UiAutomatorBridge mUiAutomatorBridge;

	private static final long REGULAR_CLICK_LENGTH = 100;

	private long mDownTime;

	// Inserted after each motion event injection.
	private static final int MOTION_EVENT_INJECTION_DELAY_MILLIS = 5;

	// long click sleep time addBy wx235140
	private static final int longClickTime = 4000;

	public InteractionController(UiAutomatorBridge bridge) {
		mUiAutomatorBridge = bridge;
	}

	/**
	 * Predicate for waiting for any of the events specified in the mask
	 */
	class WaitForAnyEventPredicate implements AccessibilityEventFilter {
		int mMask;

		WaitForAnyEventPredicate(int mask) {
			mMask = mask;
		}

		@Override
		public boolean accept(AccessibilityEvent t) {
			// check current event in the list
			if ((t.getEventType() & mMask) != 0) {
				return true;
			}

			// no match yet
			return false;
		}
	}

	/**
	 * Predicate for waiting for all the events specified in the mask and
	 * populating a ctor passed list with matching events. User of this
	 * Predicate must recycle all populated events in the events list.
	 */
	class EventCollectingPredicate implements AccessibilityEventFilter {
		int mMask;
		List<AccessibilityEvent> mEventsList;

		EventCollectingPredicate(int mask, List<AccessibilityEvent> events) {
			mMask = mask;
			mEventsList = events;
		}

		@Override
		public boolean accept(AccessibilityEvent t) {
			// check current event in the list
			if ((t.getEventType() & mMask) != 0) {
				// For the events you need, always store a copy when returning
				// false from
				// predicates since the original will automatically be recycled
				// after the call.
				mEventsList.add(AccessibilityEvent.obtain(t));
			}

			// get more
			return false;
		}
	}

	/**
	 * Predicate for waiting for every event specified in the mask to be matched
	 * at least once
	 */
	class WaitForAllEventPredicate implements AccessibilityEventFilter {
		int mMask;

		WaitForAllEventPredicate(int mask) {
			mMask = mask;
		}

		@Override
		public boolean accept(AccessibilityEvent t) {
			// check current event in the list
			if ((t.getEventType() & mMask) != 0) {
				// remove from mask since this condition is satisfied
				mMask &= ~t.getEventType();

				// Since we're waiting for all events to be matched at least
				// once
				if (mMask != 0)
					return false;

				// all matched
				return true;
			}

			// no match yet
			return false;
		}
	}

	/**
	 * Helper used by methods to perform actions and wait for any accessibility
	 * events and return predicated on predefined filter.
	 * 
	 * @param command
	 * @param filter
	 * @param timeout
	 * @return
	 */
	private AccessibilityEvent runAndWaitForEvents(Runnable command,
			AccessibilityEventFilter filter, long timeout) {

		try {
			return mUiAutomatorBridge
					.executeCommandAndWaitForAccessibilityEvent(command,
							filter, timeout);
		} catch (TimeoutException e) {
			Log.w(LOG_TAG, "runAndwaitForEvent timedout waiting for events");
			return null;
		} catch (Exception e) {
			Log.e(LOG_TAG,
					"exception from executeCommandAndWaitForAccessibilityEvent",
					e);
			return null;
		}
	}

	/**
	 * Send keys and blocks until the first specified accessibility event.
	 * 
	 * Most key presses will cause some UI change to occur. If the device is
	 * busy, this will block until the device begins to process the key press at
	 * which point the call returns and normal wait for idle processing may
	 * begin. If no events are detected for the timeout period specified, the
	 * call will return anyway with false.
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param eventType
	 * @param timeout
	 * @return true if events is received, otherwise false.
	 */
	public boolean sendKeyAndWaitForEvent(final int keyCode,
			final int metaState, final int eventType, long timeout) {
		Runnable command = new Runnable() {
			@Override
			public void run() {
				final long eventTime = SystemClock.uptimeMillis();
				KeyEvent downEvent = new KeyEvent(eventTime, eventTime,
						KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
						KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
						InputDevice.SOURCE_KEYBOARD);
				if (injectEventSync(downEvent)) {
					KeyEvent upEvent = new KeyEvent(eventTime, eventTime,
							KeyEvent.ACTION_UP, keyCode, 0, metaState,
							KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
							InputDevice.SOURCE_KEYBOARD);
					injectEventSync(upEvent);
				}
			}
		};

		return runAndWaitForEvents(command, new WaitForAnyEventPredicate(
				eventType), timeout) != null;
	}

	/**
	 * Clicks at coordinates without waiting for device idle. This may be used
	 * for operations that require stressing the target.
	 * 
	 * @param x
	 * @param y
	 * @return true if the click executed successfully
	 */
	public boolean clickNoSync(int x, int y) {
		return clickNoSync(x, y, REGULAR_CLICK_LENGTH);
	}

	/**
	 * Click at coordinates and blocks until either accessibility event
	 * TYPE_WINDOW_CONTENT_CHANGED or TYPE_VIEW_SELECTED are received.
	 * 
	 * @param x
	 * @param y
	 * @param downtime
	 *            click down time
	 * @return true if events are received, else false if timeout.
	 */
	public boolean clickNoSync(int x, int y, long downtime) {
		if (DEBUG) {
			Log.d(LOG_TAG,
					String.format("clickNoSync(%d, %d, %l)", x, y, downtime));
		}

		if (touchDown(x, y)) {
			SystemClock.sleep(downtime);
			if (touchUp(x, y)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Click at coordinates and blocks until either accessibility event
	 * TYPE_WINDOW_CONTENT_CHANGED or TYPE_VIEW_SELECTED are received.
	 * 
	 * @param x
	 * @param y
	 * @param timeout
	 *            waiting for event
	 * @return true if events are received, else false if timeout.
	 */
	public boolean clickAndSync(int x, int y, long timeout) {
		return clickAndSync(x, y, timeout, REGULAR_CLICK_LENGTH);
	}

	/**
	 * Click at coordinates and blocks until either accessibility event
	 * TYPE_WINDOW_CONTENT_CHANGED or TYPE_VIEW_SELECTED are received.
	 * 
	 * @param x
	 * @param y
	 * @param timeout
	 *            waiting for event * @param downtime click down time
	 * @return true if events are received, else false if timeout.
	 */
	public boolean clickAndSync(int x, int y, long timeout, long downtime) {
		// String logString = String.format("clickAndSync(%d, %d, %l)", x, y,
		// timeout);
		// Log.d(LOG_TAG, logString);
		return runAndWaitForEvents(clickRunnable(x, y, downtime),
				new WaitForAnyEventPredicate(
						AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED
								| AccessibilityEvent.TYPE_VIEW_SELECTED
								| AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED // add
																				// by
																				// zwx235140
																				// 点击弹框控件触发
								| AccessibilityEvent.TYPE_VIEW_CLICKED // add by
																		// zwx235140
				), timeout) != null;
	}

	/**
	 * Clicks at coordinates and waits for for a TYPE_WINDOW_STATE_CHANGED event
	 * followed by TYPE_WINDOW_CONTENT_CHANGED. If timeout occurs waiting for
	 * TYPE_WINDOW_STATE_CHANGED, no further waits will be performed and the
	 * function returns.
	 * 
	 * @param x
	 * @param y
	 * @param timeout
	 *            waiting for event
	 * @return true if both events occurred in the expected order
	 */
	public boolean clickAndWaitForNewWindow(final int x, final int y,
			long timeout) {
		String logString = String.format("clickAndWaitForNewWindow(%d, %d)", x,
				y);
		Log.d(LOG_TAG, logString);

		return runAndWaitForEvents(
				clickRunnable(x, y, REGULAR_CLICK_LENGTH),
				new WaitForAllEventPredicate(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED
								| AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED),
				timeout) != null;
	}

/**
     * Returns a Runnable for use in {@link #runAndWaitForEvents(Runnable, Predicate, long) to
     * perform a click.
     *
     * @param x coordinate
     * @param y coordinate
     * @return Runnable
     */
	private Runnable clickRunnable(final int x, final int y, final long downtime) {
		return new Runnable() {
			@Override
			public void run() {
				if (touchDown(x, y)) {
					SystemClock.sleep(downtime);
					touchUp(x, y);
				}
			}
		};
	}

	/**
	 * Touches down for a long press at the specified coordinates.
	 * 
	 * @param x
	 * @param y
	 * @return true if successful.
	 */
	public boolean longTapNoSync(int x, int y) {
		if (DEBUG) {
			Log.d(LOG_TAG, "longTapNoSync (" + x + ", " + y + ")");
		}

		if (touchDown(x, y)) {
			SystemClock.sleep(longClickTime);// old value
												// mUiAutomatorBridge.getSystemLongPressTime()===500
			if (touchUp(x, y)) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Touches down for a long press at the specified coordinates.
	 * 
	 * @param x
	 * @param y
	 * @return true if successful.
	 */
	public boolean longTapNoSync(int x, int y,int waitTime) {
		if (DEBUG) {
			Log.d(LOG_TAG, "longTapNoSync (" + x + ", " + y + ")");
		}

		if (touchDown(x, y)) {
			SystemClock.sleep(waitTime);// old value
												// mUiAutomatorBridge.getSystemLongPressTime()===500
			if (touchUp(x, y)) {
				return true;
			}
		}
		return false;
	}

	private boolean touchDown(int x, int y) {
		Log.d(LOG_TAG, "touchDown (" + x + ", " + y + ")");
		mDownTime = SystemClock.uptimeMillis();
		MotionEvent event = MotionEvent.obtain(mDownTime, mDownTime,
				MotionEvent.ACTION_DOWN, x, y, 1);
		// MotionEvent event = MotionEvent.obtain(mDownTime, mDownTime,
		// MotionEvent.ACTION_DOWN, x, y, 1.0f, 1.0f, 1, 1.0f, 1.0f, 4, 0);
		event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
		return injectEventSync(event);
	}

	private boolean touchUp(int x, int y) {
		Log.d(LOG_TAG, "touchUp (" + x + ", " + y + ")");
		final long eventTime = SystemClock.uptimeMillis();
		MotionEvent event = MotionEvent.obtain(mDownTime, eventTime,
				MotionEvent.ACTION_UP, x, y, 1);
		// MotionEvent event = MotionEvent.obtain(mDownTime, eventTime,
		// MotionEvent.ACTION_UP, x, y, 1.0f, 1.0f, 1, 1.0f, 1.0f, 4, 0);
		event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
		mDownTime = 0;
		return injectEventSync(event);
	}

	private boolean touchMove(int x, int y) {
		Log.d(LOG_TAG, "touchMove (" + x + ", " + y + ")");
		final long eventTime = SystemClock.uptimeMillis();
		MotionEvent event = MotionEvent.obtain(mDownTime, eventTime,
				MotionEvent.ACTION_MOVE, x, y, 1);
		event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
		return injectEventSync(event);
	}

	/**
	 * Handle swipes in any direction where the result is a scroll event. This
	 * call blocks until the UI has fired a scroll event or timeout.
	 * 
	 * @param downX
	 * @param downY
	 * @param upX
	 * @param upY
	 * @param steps
	 * @return true if we are not at the beginning or end of the scrollable
	 *         view.
	 */
	public boolean scrollSwipe(final int downX, final int downY, final int upX,
			final int upY, final int steps) {
		Log.d(LOG_TAG, "scrollSwipe (" + downX + ", " + downY + ", " + upX
				+ ", " + upY + ", " + steps + ")");

		Runnable command = new Runnable() {
			@Override
			public void run() {
				swipe(downX, downY, upX, upY, steps);
			}
		};

		// Collect all accessibility events generated during the swipe command
		// and get the
		// last event
		ArrayList<AccessibilityEvent> events = new ArrayList<AccessibilityEvent>();
		runAndWaitForEvents(command, new EventCollectingPredicate(
				AccessibilityEvent.TYPE_VIEW_SCROLLED, events), Configurator
				.getInstance().getScrollAcknowledgmentTimeout());

		AccessibilityEvent event = getLastMatchingEvent(events,
				AccessibilityEvent.TYPE_VIEW_SCROLLED);

		if (event == null) {
			// end of scroll since no new scroll events received
			recycleAccessibilityEvents(events);
			return false;
		}

		// AdapterViews have indices we can use to check for the beginning.
		boolean foundEnd = false;
		if (event.getFromIndex() != -1 && event.getToIndex() != -1
				&& event.getItemCount() != -1) {
			foundEnd = event.getFromIndex() == 0
					|| (event.getItemCount() - 1) == event.getToIndex();
			Log.d(LOG_TAG, "scrollSwipe reached scroll end: " + foundEnd);
		} else if (event.getScrollX() != -1 && event.getScrollY() != -1) {
			// Determine if we are scrolling vertically or horizontally.
			if (downX == upX) {
				// Vertical
				foundEnd = event.getScrollY() == 0
						|| event.getScrollY() == event.getMaxScrollY();
				Log.d(LOG_TAG, "Vertical scrollSwipe reached scroll end: "
						+ foundEnd);
			} else if (downY == upY) {
				// Horizontal
				foundEnd = event.getScrollX() == 0
						|| event.getScrollX() == event.getMaxScrollX();
				Log.d(LOG_TAG, "Horizontal scrollSwipe reached scroll end: "
						+ foundEnd);
			}
		}
		recycleAccessibilityEvents(events);
		return !foundEnd;
	}

	private AccessibilityEvent getLastMatchingEvent(
			List<AccessibilityEvent> events, int type) {
		for (int x = events.size(); x > 0; x--) {
			AccessibilityEvent event = events.get(x - 1);
			if (event.getEventType() == type)
				return event;
		}
		return null;
	}

	private void recycleAccessibilityEvents(List<AccessibilityEvent> events) {
		for (AccessibilityEvent event : events)
			event.recycle();
		events.clear();
	}

	/**
	 * Handle swipes in any direction.
	 * 
	 * @param downX
	 * @param downY
	 * @param upX
	 * @param upY
	 * @param steps
	 * @return true if the swipe executed successfully
	 */
	public boolean swipe(int downX, int downY, int upX, int upY, int steps) {
		return swipe(downX, downY, upX, upY, steps, false /* drag */);
	}

	/**
	 * Handle swipes/drags in any direction.
	 * 
	 * @param downX
	 * @param downY
	 * @param upX
	 * @param upY
	 * @param steps
	 * @param drag
	 * @param downTime
	 * @param upWaitTime
	 *            when true, the swipe becomes a drag swipe
	 * @return true if the swipe executed successfully
	 * @author zWX235140
	 */
	public boolean swipe(int downX, int downY, int upX, int upY, int steps,
			boolean drag, Long downTime, Long upWaitTime) {
		Log.d(LOG_TAG,
				String.format(
						"drag params>>downX:%d;downY:%d;upX:%d;upY:%d;steps:%d;drag:%b;",
						downX, downY, upX, upY, steps, drag));
		boolean ret = false;
		int swipeSteps = steps;
		double xStep = 0;
		double yStep = 0;

		// avoid a divide by zero
		if (swipeSteps == 0)
			swipeSteps = 1;

		xStep = ((double) (upX - downX)) / swipeSteps;
		yStep = ((double) (upY - downY)) / swipeSteps;

		// first touch starts exactly at the point requested
		ret = touchDown(downX, downY);
		if (drag)
			if (downTime == null || downTime <= 0L) {
				downTime = 2500L;
			}
		Log.d(LOG_TAG, "touchDown wait downTime:" + downTime);
		SystemClock.sleep(downTime);
		for (int i = 1; i < swipeSteps; i++) {
			// ret &= touchMove(downX + (int) (xStep * i), downY
			// + (int) (yStep * i));

			// if (ret == false)
			// break;

			/*
			 * 有偶现注册事件失败的情况，这里增加重试机制 zwx235140 2016/8/5
			 */
			for (int j = 0; j <= 1; j++) {
				ret &= touchMove(downX + (int) (xStep * i), downY
						+ (int) (yStep * i));
				if (ret) {
					Log.d(LOG_TAG, "touchMove is ok.");
					break;
				} else {
					Log.d(LOG_TAG, "touchMove is faild!try again.");
				}
			}

			// set some known constant delay between steps as without it this
			// become completely dependent on the speed of the system and
			// results
			// may vary on different devices. This guarantees at minimum we have
			// a preset delay.
			SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
		}
		if (drag)
			if (upWaitTime == null || upWaitTime <= 0L) {
				upWaitTime = 1500L;
			}
		SystemClock.sleep(upWaitTime); // old value: REGULAR_CLICK_LENGTH
		ret &= touchUp(upX, upY);
		return (ret);
	}

	/**
	 * 两个控件进行滑动挤位
	 * 
	 * @author zwx235140
	 * @param downX
	 * @param downY
	 * @param upX
	 * @param upY
	 * @param steps
	 * @param dstWidth
	 *            目标控件宽度
	 * @param dstHigh
	 *            目标控件高度
	 * @param relativePosition
	 *            目标控件相对于起始控件的位置关系 Object.LEFT_UP/...
	 * @param occupyType
	 *            挤位类型； 包括1、workspace(在桌面挤位) 2、folder(在文件夹内挤位) 3、dock(dock区域挤位)
	 *            主要是用来处理为dock区域挤位时的目标坐标计算
	 * @return
	 */
	public boolean swipeOccupy(int downX, int downY, int upX, int upY,
			int steps, int dstWidth, int dstHigh, int relativePosition,
			String occupyType) {
		Log.d(LOG_TAG,
				String.format(
						"into swipeOccupy, params>>downX:%d;downY:%d;upX:%d;upY:%d;steps:%d;dstWidth:%d;dstHigh:%d;relativePosition:%d",
						downX, downY, upX, upY, steps, dstWidth, dstHigh,
						relativePosition));
		boolean ret = false;
		int swipeSteps = steps;
		double xStep = 0;
		double yStep = 0;
		int tmpx = 0;
		int tmpy = 0;
		/*
		 * 目的坐标
		 */
		int target_x = 0;
		int target_y = 0;

		// 热区范围
		double hotarea_start_x = upX - 0.2 * dstWidth;
		double hotarea_end_x = upX + 0.2 * dstWidth;
		double hotarea_start_y = upY - 0.2 * dstHigh;
		double hotarea_end_y = upY + 0.2 * dstHigh;

		StringBuilder sb = new StringBuilder();
		sb.append("Hot area zone-->>> x=[ ");
		sb.append(hotarea_start_x);
		sb.append("---");
		sb.append(hotarea_end_x);
		sb.append(" ]");
		sb.append("y=[ ");
		sb.append(hotarea_start_y);
		sb.append("---");
		sb.append(hotarea_end_y);
		sb.append(" ]");

		Log.d(LOG_TAG, sb.toString());

		// avoid a divide by zero
		if (swipeSteps == 0)
			swipeSteps = 1;

		/*
		 * 根据目标控件与起始控件相对位置,计算目标坐标 计算方式已控件形成挤位时的热区范围值进行
		 */

		switch (relativePosition) {
		case UiObject.LEFT_UP:
			target_x = upX;
			target_y = (int) hotarea_start_y;
			break;
		case UiObject.LEFT:
			if (occupyType.equalsIgnoreCase("dock")) {
				// dock区只有左，右之间互相挤位
				target_x = (int) hotarea_start_x - 23;
				target_y = upY - 10;
			} else {
				target_x = (int) hotarea_start_x;
				target_y = upY;
			}
			break;
		case UiObject.LEFT_DWON:
			target_x = (int) hotarea_end_x;
			target_y = upY;
			break;
		case UiObject.DOWN:
			target_x = (int) hotarea_end_x;
			target_y = upY;
			break;
		case UiObject.RIGHT_DOWN:
			target_x = upX;
			target_y = (int) hotarea_end_y;
			break;
		case UiObject.RIGHT:
			if (occupyType.equalsIgnoreCase("dock")) {
				target_x = (int) hotarea_end_x + 23;
				target_y = upY - 10;
			} else {
				target_x = (int) hotarea_end_x;
				target_y = upY;
			}

			break;
		case UiObject.RIGHT_UP:
			target_x = (int) hotarea_start_x;
			target_y = upY;
			break;
		case UiObject.UP:
			target_x = upX;
			target_y = (int) hotarea_start_y;
			break;
		default:
			Log.d(LOG_TAG, "relativePosition is ERROR!");
			target_x = upX;
			target_y = upY;
			break;
		}

		Log.d(LOG_TAG, String.format("the target location->> (%d,%d)",
				target_x, target_y));

		xStep = ((double) (target_x - downX)) / swipeSteps;
		yStep = ((double) (target_y - downY)) / swipeSteps;

		// first touch starts exactly at the point requested
		ret = touchDown(downX, downY);
		SystemClock.sleep(1000L);
		for (int i = 1; i <= swipeSteps; i++) {
			Log.d(LOG_TAG, "i:" + i);
			tmpx = downX + (int) (xStep * i);
			tmpy = downY + (int) (yStep * i);
			Log.d(LOG_TAG, String.format("next move location: x=%d, y=%d ",
					tmpx, tmpy));
			//
			// //可能存tmpx和tmpy就是目标控件的中心点坐标的问题
			// if(tmpx == upX && tmpy== upY)
			// {
			// Log.d(LOG_TAG,
			// "The next coordinate is the center point of the target node!");
			// tmpx = (int)upX;
			// tmpy = (int)hotarea_start_y;
			// Log.d(LOG_TAG,
			// String.format("Objective to re calculate the coordinates of hot spots >> (%d,%d)",
			// tmpx, tmpy));
			// }

			ret &= touchMove(tmpx, tmpy);
			if (ret == false)
				break;
			// if((tmpx > hotarea_start_x && tmpx < hotarea_end_x) && (tmpx >
			// hotarea_start_y && tmpx < hotarea_end_y) )
			// {
			// //源控件中心点已滑入目标控件热点区域
			// Log.d(LOG_TAG, "Has entered a hot area!");
			// break;
			// }
			// set some known constant delay between steps as without it this
			// become completely dependent on the speed of the system and
			// results
			// may vary on different devices. This guarantees at minimum we have
			// a preset delay.
			SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
		}
		// 要形成挤位效果，在滑动到预期区域之后停留的时间需要大于350ms
		if (occupyType.equalsIgnoreCase("dock")) {
			SystemClock.sleep(2000L);
		} else {
			SystemClock.sleep(1000L);
		}
		ret &= touchUp(tmpx, tmpy);
		return (ret);
	}

	/**
	 * Handle swipes/drags in any direction.
	 * 
	 * @param downX
	 * @param downY
	 * @param upX
	 * @param upY
	 * @param steps
	 * @param drag
	 *            when true, the swipe becomes a drag swipe
	 * @return true if the swipe executed successfully
	 */
	public boolean swipe(int downX, int downY, int upX, int upY, int steps,
			boolean drag) {
		boolean ret = false;
		int swipeSteps = steps;
		double xStep = 0;
		double yStep = 0;

		// avoid a divide by zero
		if (swipeSteps == 0)
			swipeSteps = 1;

		xStep = ((double) (upX - downX)) / swipeSteps;
		yStep = ((double) (upY - downY)) / swipeSteps;

		// first touch starts exactly at the point requested
		ret = touchDown(downX, downY);
		if (drag)
			SystemClock.sleep(2500); // old vaule：
										// mUiAutomatorBridge.getSystemLongPressTime()
										// == 500
		for (int i = 1; i < swipeSteps; i++) {
			ret &= touchMove(downX + (int) (xStep * i), downY
					+ (int) (yStep * i));
			if (ret == false)
				break;
			// set some known constant delay between steps as without it this
			// become completely dependent on the speed of the system and
			// results
			// may vary on different devices. This guarantees at minimum we have
			// a preset delay.
			SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
		}
		if (drag)
			SystemClock.sleep(1500); // old value: REGULAR_CLICK_LENGTH
		ret &= touchUp(upX, upY);
		return (ret);
	}

	/**
	 * Performs a swipe between points in the Point array.
	 * 
	 * @param segments
	 *            is Point array containing at least one Point object
	 * @param segmentSteps
	 *            steps to inject between two Points
	 * @return true on success
	 */
	public boolean swipe(Point[] segments, int segmentSteps) {
		boolean ret = false;
		int swipeSteps = segmentSteps;
		double xStep = 0;
		double yStep = 0;

		// avoid a divide by zero
		if (segmentSteps == 0)
			segmentSteps = 1;

		// must have some points
		if (segments.length == 0)
			return false;

		// first touch starts exactly at the point requested
		ret = touchDown(segments[0].x, segments[0].y);
		for (int seg = 0; seg < segments.length; seg++) {
			if (seg + 1 < segments.length) {

				xStep = ((double) (segments[seg + 1].x - segments[seg].x))
						/ segmentSteps;
				yStep = ((double) (segments[seg + 1].y - segments[seg].y))
						/ segmentSteps;

				for (int i = 1; i < swipeSteps; i++) {
					ret &= touchMove(segments[seg].x + (int) (xStep * i),
							segments[seg].y + (int) (yStep * i));
					if (ret == false)
						break;
					// set some known constant delay between steps as without it
					// this
					// become completely dependent on the speed of the system
					// and results
					// may vary on different devices. This guarantees at minimum
					// we have
					// a preset delay.
					SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
				}
			}
		}
		ret &= touchUp(segments[segments.length - 1].x,
				segments[segments.length - 1].y);
		return (ret);
	}

	public boolean sendText(String text) {
		if (DEBUG) {
			Log.d(LOG_TAG, "sendText (" + text + ")");
		}

		KeyEvent[] events = mKeyCharacterMap.getEvents(text.toCharArray());

		if (events != null) {
			long keyDelay = Configurator.getInstance().getKeyInjectionDelay();
			for (KeyEvent event2 : events) {
				// We have to change the time of an event before injecting it
				// because
				// all KeyEvents returned by KeyCharacterMap.getEvents() have
				// the same
				// time stamp and the system rejects too old events. Hence, it
				// is
				// possible for an event to become stale before it is injected
				// if it
				// takes too long to inject the preceding ones.
				KeyEvent event = KeyEvent.changeTimeRepeat(event2,
						SystemClock.uptimeMillis(), 0);
				if (!injectEventSync(event)) {
					return false;
				}
				SystemClock.sleep(keyDelay);
			}
		}
		return true;
	}

	public boolean sendKey(int keyCode, int metaState) {
		if (DEBUG) {
			Log.d(LOG_TAG, "sendKey (" + keyCode + ", " + metaState + ")");
		}

		final long eventTime = SystemClock.uptimeMillis();
		KeyEvent downEvent = new KeyEvent(eventTime, eventTime,
				KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
				KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
				InputDevice.SOURCE_KEYBOARD);
		if (injectEventSync(downEvent)) {
			KeyEvent upEvent = new KeyEvent(eventTime, eventTime,
					KeyEvent.ACTION_UP, keyCode, 0, metaState,
					KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
					InputDevice.SOURCE_KEYBOARD);
			if (injectEventSync(upEvent)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Rotates right and also freezes rotation in that position by disabling the
	 * sensors. If you want to un-freeze the rotation and re-enable the sensors
	 * see {@link #unfreezeRotation()}. Note that doing so may cause the screen
	 * contents to rotate depending on the current physical position of the test
	 * device.
	 * 
	 * @throws RemoteException
	 */
	public void setRotationRight() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_FREEZE_270);
	}

	/**
	 * Rotates left and also freezes rotation in that position by disabling the
	 * sensors. If you want to un-freeze the rotation and re-enable the sensors
	 * see {@link #unfreezeRotation()}. Note that doing so may cause the screen
	 * contents to rotate depending on the current physical position of the test
	 * device.
	 * 
	 * @throws RemoteException
	 */
	public void setRotationLeft() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_FREEZE_90);
	}

	/**
	 * Rotates up and also freezes rotation in that position by disabling the
	 * sensors. If you want to un-freeze the rotation and re-enable the sensors
	 * see {@link #unfreezeRotation()}. Note that doing so may cause the screen
	 * contents to rotate depending on the current physical position of the test
	 * device.
	 * 
	 * @throws RemoteException
	 */
	public void setRotationNatural() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_FREEZE_0);
	}

	/**
	 * Disables the sensors and freezes the device rotation at its current
	 * rotation state.
	 * 
	 * @throws RemoteException
	 */
	public void freezeRotation() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_FREEZE_CURRENT);
	}

	/**
	 * 设置手机屏幕倒竖屏
	 * 
	 * @author zWX235140
	 */
	public void setRotationPortrait() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_FREEZE_180);
	}

	/**
	 * Re-enables the sensors and un-freezes the device rotation allowing its
	 * contents to rotate with the device physical rotation.
	 * 
	 * @throws RemoteException
	 */
	public void unfreezeRotation() {
		mUiAutomatorBridge.setRotation(UiAutomation.ROTATION_UNFREEZE);
	}

	/**
	 * This method simply presses the power button if the screen is OFF else it
	 * does nothing if the screen is already ON.
	 * 
	 * @return true if the device was asleep else false
	 * @throws RemoteException
	 */
	public boolean wakeDevice() throws RemoteException {
		if (!isScreenOn()) {
			sendKey(KeyEvent.KEYCODE_POWER, 0);
			return true;
		}
		return false;
	}

	/**
	 * This method simply presses the power button if the screen is ON else it
	 * does nothing if the screen is already OFF.
	 * 
	 * @return true if the device was awake else false
	 * @throws RemoteException
	 */
	public boolean sleepDevice() throws RemoteException {
		if (isScreenOn()) {
			this.sendKey(KeyEvent.KEYCODE_POWER, 0);
			return true;
		}
		return false;
	}

	/**
	 * Checks the power manager if the screen is ON
	 * 
	 * @return true if the screen is ON else false
	 * @throws RemoteException
	 */
	public boolean isScreenOn() throws RemoteException {
		return mUiAutomatorBridge.isScreenOn();
	}

	public boolean injectEventSync(InputEvent event) {
		/*
		 * 注册事件时有偶现注册失败的问题。InputManager: Input event injection from pid 30001
		 * failed. 为了提高稳定性，这里增加重试机制。 zwx235140 20160906
		 */
		for (int i = 0; i < 3; i++) {
			// 重试三次
			boolean result = mUiAutomatorBridge.injectInputEvent(event, true);
			if (result) {
				return result;
			}
			try {
				Log.i(LOG_TAG, "injectEventSync try again!");
				Thread.sleep(500);
			} catch (Exception e) {
				e.printStackTrace();
			}

		}
		return false;
		// return mUiAutomatorBridge.injectInputEvent(event, true);
	}

	private int getPointerAction(int motionEnvent, int index) {
		return motionEnvent + (index << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
	}

	/**
	 * Performs a multi-touch gesture
	 * 
	 * Takes a series of touch coordinates for at least 2 pointers. Each pointer
	 * must have all of its touch steps defined in an array of
	 * {@link PointerCoords}. By having the ability to specify the touch points
	 * along the path of a pointer, the caller is able to specify complex
	 * gestures like circles, irregular shapes etc, where each pointer may take
	 * a different path.
	 * 
	 * To create a single point on a pointer's touch path <code>
	 *       PointerCoords p = new PointerCoords();
	 *       p.x = stepX;
	 *       p.y = stepY;
	 *       p.pressure = 1;
	 *       p.size = 1;
	 * </code>
	 * 
	 * @param touches
	 *            each array of {@link PointerCoords} constitute a single
	 *            pointer's touch path. Multiple {@link PointerCoords} arrays
	 *            constitute multiple pointers, each with its own path. Each
	 *            {@link PointerCoords} in an array constitute a point on a
	 *            pointer's path.
	 * @return <code>true</code> if all points on all paths are injected
	 *         successfully, <code>false
	 *        </code>otherwise
	 * @since API Level 18
	 */
	public boolean performMultiPointerGesture(PointerCoords[]... touches) {
		boolean ret = true;
		if (touches.length < 2) {
			throw new IllegalArgumentException(
					"Must provide coordinates for at least 2 pointers");
		}

		// Get the pointer with the max steps to inject.
		int maxSteps = 0;
		for (int x = 0; x < touches.length; x++)
			maxSteps = (maxSteps < touches[x].length) ? touches[x].length
					: maxSteps;

		// specify the properties for each pointer as finger touch
		PointerProperties[] properties = new PointerProperties[touches.length];
		PointerCoords[] pointerCoords = new PointerCoords[touches.length];
		for (int x = 0; x < touches.length; x++) {
			PointerProperties prop = new PointerProperties();
			prop.id = x;
			prop.toolType = MotionEvent.TOOL_TYPE_FINGER;
			properties[x] = prop;

			// for each pointer set the first coordinates for touch down
			pointerCoords[x] = touches[x][0];
		}

		// Touch down all pointers
		long downTime = SystemClock.uptimeMillis();
		MotionEvent event;
		event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
				MotionEvent.ACTION_DOWN, 1, properties, pointerCoords, 0, 0, 1,
				1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);
		ret &= injectEventSync(event);

		for (int x = 1; x < touches.length; x++) {
			event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
					getPointerAction(MotionEvent.ACTION_POINTER_DOWN, x),
					x + 1, properties, pointerCoords, 0, 0, 1, 1, 0, 0,
					InputDevice.SOURCE_TOUCHSCREEN, 0);
			ret &= injectEventSync(event);
		}

		// Move all pointers
		for (int i = 1; i < maxSteps - 1; i++) {
			// for each pointer
			for (int x = 0; x < touches.length; x++) {
				// check if it has coordinates to move
				if (touches[x].length > i)
					pointerCoords[x] = touches[x][i];
				else
					pointerCoords[x] = touches[x][touches[x].length - 1];
			}

			event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
					MotionEvent.ACTION_MOVE, touches.length, properties,
					pointerCoords, 0, 0, 1, 1, 0, 0,
					InputDevice.SOURCE_TOUCHSCREEN, 0);

			ret &= injectEventSync(event);
			SystemClock.sleep(MOTION_EVENT_INJECTION_DELAY_MILLIS);
		}

		// For each pointer get the last coordinates
		for (int x = 0; x < touches.length; x++)
			pointerCoords[x] = touches[x][touches[x].length - 1];

		// touch up
		for (int x = 1; x < touches.length; x++) {
			event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
					getPointerAction(MotionEvent.ACTION_POINTER_UP, x), x + 1,
					properties, pointerCoords, 0, 0, 1, 1, 0, 0,
					InputDevice.SOURCE_TOUCHSCREEN, 0);
			ret &= injectEventSync(event);
		}

		Log.i(LOG_TAG, "x " + pointerCoords[0].x);
		// first to touch down is last up
		event = MotionEvent.obtain(downTime, SystemClock.uptimeMillis(),
				MotionEvent.ACTION_UP, 1, properties, pointerCoords, 0, 0, 1,
				1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);
		ret &= injectEventSync(event);
		return ret;
	}

	/**
	 * Simulates a short press on the Recent Apps button.
	 * 
	 * @return true if successful, else return false
	 * @since API Level 18
	 */
	public boolean toggleRecentApps() {
		return mUiAutomatorBridge
				.performGlobalAction(AccessibilityService.GLOBAL_ACTION_RECENTS);
	}

	/**
	 * Opens the notification shade
	 * 
	 * @return true if successful, else return false
	 * @since API Level 18
	 */
	public boolean openNotification() {
		return mUiAutomatorBridge
				.performGlobalAction(AccessibilityService.GLOBAL_ACTION_NOTIFICATIONS);
	}

	/**
	 * Opens the quick settings shade
	 * 
	 * @return true if successful, else return false
	 * @since API Level 18
	 */
	public boolean openQuickSettings() {
		return mUiAutomatorBridge
				.performGlobalAction(AccessibilityService.GLOBAL_ACTION_QUICK_SETTINGS);
	}

	/**
	 * 长按坐标
	 * 
	 * @author n00221817
	 * @param x
	 * @param y
	 * @param time
	 * @author n00221817
	 * @return
	 */
	public boolean longClickNoSync(int x, int y, int time) {
		Log.d(LOG_TAG, "clickNoSync (" + x + ", " + y + ")");

		if (touchDown(x, y)) {
			SystemClock.sleep(time);
			if (touchUp(x, y))
				return true;
		}
		return false;
	}

	/**
	 * 发送按键down事件之后等待time后发送up时间
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param time
	 * @author n00221817
	 * @return
	 */
	public boolean sendKeyAndWait(int keyCode, int metaState, int time) {
		Log.d(LOG_TAG, "sendKey (" + keyCode + ", " + metaState + ")");

		final long eventTime = SystemClock.uptimeMillis();
		KeyEvent downEvent = new KeyEvent(eventTime, eventTime,
				KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
				KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 8,
				InputDevice.SOURCE_KEYBOARD);
		// KeyEvent downEvent = KeyEvent.obtain(eventTime, eventTime,
		// KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
		// KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 8, 1654827008,
		// InputDevice.SOURCE_KEYBOARD,"");
		if (injectEventSync(downEvent)) {
			SystemClock.sleep(time);
			KeyEvent upEvent = new KeyEvent(eventTime, eventTime,
					KeyEvent.ACTION_UP, keyCode, 0, metaState,
					KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 8,
					InputDevice.SOURCE_KEYBOARD);
			if (injectEventSync(upEvent)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Clicks at coordinates without waiting for device idle. This may be used
	 * for operations that require stressing the target.
	 * 
	 * @param x
	 * @param y
	 * @param type
	 * @return true if the click executed successfully
	 * @author x00226925
	 */
	public boolean clickNoSync(int x, int y, String type, int time) {
		if (type.equalsIgnoreCase("DOWN")) {
			return touchDown(x, y);
		} else if (type.equalsIgnoreCase("MOVE")) {
			return touchMove(x, y);
		} else if (type.equalsIgnoreCase("UP")) {
			return touchUp(x, y);
		} else if (type.equalsIgnoreCase("LONG")) {
			return clickNoSync(x, y, time);
		} else if (type.equalsIgnoreCase("DOUBLE")) {
			clickNoSync(x, y, time);
			return clickNoSync(x, y, time);
		} else {
			return clickNoSync(x, y, REGULAR_CLICK_LENGTH);
		}
	}

	/**
	 * Clicks at coordinates without waiting for device idle. This may be used
	 * for operations that require stressing the target.
	 * 
	 * @param x
	 * @param y
	 * @param type
	 * @return true if the click executed successfully
	 * @author x00226925
	 */
	public boolean clickAndSync(int x, int y, String type, int downtime,
			int timeout) {
		if (type.equalsIgnoreCase("DOWN")) {
			return touchDown(x, y);
		} else if (type.equalsIgnoreCase("MOVE")) {
			return touchMove(x, y);
		} else if (type.equalsIgnoreCase("UP")) {
			return touchUp(x, y);
		} else if (type.equalsIgnoreCase("LONG")) {
			return clickAndSync(x, y, timeout, downtime);
		} else if (type.equalsIgnoreCase("DOUBLE")) {
			clickAndSync(x, y, timeout, downtime);
			try {
				// 双击之间的间隔
				Thread.sleep(100);
			} catch (Exception e) {
				// TODO: handle exception
			}
			return clickAndSync(x, y, timeout, downtime);
		} else {
			return clickAndSync(x, y, timeout, downtime);
		}
	}

	/**
	 * Send keys and blocks until the first specified accessibility event.
	 * 
	 * Most key presses will cause some UI change to occur. If the device is
	 * busy, this will block until the device begins to process the key press at
	 * which point the call returns and normal wait for idle processing may
	 * begin. If no events are detected for the timeout period specified, the
	 * call will return anyway with false.
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param type
	 *            按键类型("NORMAL"/"LONG"/"DOWN"/"UP")
	 * @param downtime
	 *            type="LONG"时的按下时间
	 * @param eventType
	 * @param timeout
	 * @return true if events is received, otherwise false.
	 * @author x00226925
	 */
	public boolean sendKeyAndWaitForEvent(final int keyCode,
			final int metaState, final String type, final int downtime,
			final int eventType, long timeout) {
		if (DEBUG) {
			Log.d(LOG_TAG, "sendKeyAndWaitForEvent (" + keyCode + ", "
					+ metaState + ")");
		}

		Runnable command = new Runnable() {
			@Override
			public void run() {
				sendKey(keyCode, metaState, type, downtime);
			}
		};

		return runAndWaitForEvents(command, new WaitForAnyEventPredicate(
				eventType), timeout) != null;
	}

	/**
	 * Send keys and blocks until the first specified accessibility event.
	 * 
	 * Most key presses will cause some UI change to occur. If the device is
	 * busy, this will block until the device begins to process the key press at
	 * which point the call returns and normal wait for idle processing may
	 * begin. If no events are detected for the timeout period specified, the
	 * call will return anyway with false.
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param type
	 *            按键类型("NORMAL"/"LONG"/"DOWN"/"UP")
	 * @param downtime
	 *            type="LONG"时的按下时间
	 * @return true if events is received, otherwise false.
	 * @author x00226925
	 */
	public boolean sendKey(final int keyCode, final int metaState,
			final String type, final int downtime) {
		if (DEBUG) {
			Log.d(LOG_TAG, "sendKeyAndWaitForEvent (" + keyCode + ", "
					+ metaState + ")");
		}

		final long eventTime = SystemClock.uptimeMillis();
		if (type.equalsIgnoreCase("NORMAL")) {
			return sendKey(keyCode, metaState);
		} else if (type.equalsIgnoreCase("DOWN")) {
			return sendKeyDown(keyCode, metaState, eventTime);
		} else if (type.equalsIgnoreCase("UP")) {
			return sendKeyUp(keyCode, metaState, eventTime);
		} else if (type.equalsIgnoreCase("LONG")) {
			return sendKeyAndWait(keyCode, metaState, downtime);
		} else {
			return sendKey(keyCode, metaState);
		}
	}

	/**
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param eventTime
	 * @return
	 * @author x00226925
	 */
	public boolean sendKeyDown(int keyCode, int metaState, long eventTime) {
		KeyEvent downEvent = new KeyEvent(eventTime, eventTime,
				KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
				KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
				InputDevice.SOURCE_KEYBOARD);
		return injectEventSync(downEvent);
	}

	/**
	 * 
	 * @param keyCode
	 * @param metaState
	 * @param eventTime
	 * @return
	 * @author x00226925
	 */
	public boolean sendKeyUp(int keyCode, int metaState, long eventTime) {
		KeyEvent upEvent = new KeyEvent(eventTime, eventTime,
				KeyEvent.ACTION_DOWN, keyCode, 0, metaState,
				KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,
				InputDevice.SOURCE_KEYBOARD);
		return injectEventSync(upEvent);
	}

	/**
	 * 
	 * @param mUiDevice
	 * @param x
	 * @param y
	 * @param forceTouch
	 *            是否重压
	 * @param sysPressure
	 *            系统当前压力灵敏度对应的默认压力值
	 * @return
	 */
	public boolean touchPress(int x, int y, boolean forceTouch,
			float sysPressure) {

		boolean ret = false;
		float defaultPressure = sysPressure;

		Log.i(LOG_TAG, "defaultPressure :" + defaultPressure);

		int step = 10;
		float maxLightPressure = defaultPressure;
		float minLightPressure = (float) (0.3 * defaultPressure);
		float lightIntervalPressure = (maxLightPressure - minLightPressure)
				/ step;
		Log.i(LOG_TAG, "maxLightPressure :" + maxLightPressure
				+ ",minLightPressure :" + minLightPressure
				+ ",lightIntervalPressure :" + lightIntervalPressure);

		float[] lightPresses = new float[step];// 获取轻压时对应的压力值
		for (int i = 0; i < step; i++) {
			lightPresses[i] = minLightPressure + lightIntervalPressure * i * 2;
		}

		ret = touchSensitivePressure(x, y, lightPresses);// 先轻压(一级按压)
		if (!ret) {
			return false;
		}
		if (forceTouch) {// 后重压(二级按压)
			Log.i(LOG_TAG, "second level pressure");

			float[] forcePresses = new float[step];
			float minForcePressure = (float) (1.3 * defaultPressure);
			float maxForcePressure = (float) (0.2 + defaultPressure);
			float forceIntervalPressure = (maxForcePressure - minForcePressure)
					/ step;
			Log.i(LOG_TAG, "maxForcePressure :" + maxForcePressure
					+ ",minForcePressure :" + minForcePressure
					+ ",forceIntervalPressure :" + forceIntervalPressure);
			for (int i = 0; i < step; i++) {// 获取重压时对应的压力值
				forcePresses[i] = minForcePressure + forceIntervalPressure * i
						* 3;
			}
			ret = touchSensitivePressure(x, y, forcePresses);
			if (!ret) {
				return false;
			}
		}
		return true;
	}

	private boolean touchSensitivePressure(int x, int y, float[] presses) {
		Log.i(LOG_TAG, "touchSensitivePressure x=" + x + ", y=" + y
				+ ",presses=" + Arrays.toString(presses));
		float DEFAULT_SIZE = 1.0f;
		int DEFAULT_META_STATE = 1;
		float DEFAULT_PRECISION_X = 1.0f;
		float DEFAULT_PRECISION_Y = 1.0f;
		int DEFAULT_EDGE_FLAGS = 0;

		int devId = getInputDeviceId(InputDevice.SOURCE_TOUCHSCREEN);
		Log.i(LOG_TAG, "devId :" + devId);

		if (touchDown(x, y)) {
			for (int i = 0; i < presses.length; i++) {
				long startTime = SystemClock.uptimeMillis();
				MotionEvent event = MotionEvent.obtain(mDownTime,
						SystemClock.uptimeMillis(), MotionEvent.ACTION_MOVE,
						/* x */x, /* y */y, /* pressure */presses[i], /* size */
						DEFAULT_SIZE,
						/* metaState */DEFAULT_META_STATE, /* xPrecision */
						DEFAULT_PRECISION_X,
						/* yPrecision */DEFAULT_PRECISION_Y, /* deviceId */
						devId, /* edgeFlags */DEFAULT_EDGE_FLAGS);
				event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
				boolean success = injectEventSync(event);
				if (!success) {
					return false;
				}
				SystemClock.sleep(15);
				long endTime = SystemClock.uptimeMillis();
				Log.i(LOG_TAG, "ACTION_MOVE i=" + i + ",costTime ="
						+ (endTime - startTime) + ",totalCostTime = "
						+ (endTime - mDownTime));
			}
			if (!touchUp(x, y)) {
				return false;
			}
			return true;
		} else {
			return false;
		}
	}

	// 获取当前操作设备的ID
	private int getInputDeviceId(int inputSource) {
		final int DEFAULT_DEVICE_ID = 0;
		int[] devIds = InputDevice.getDeviceIds();
		for (int devId : devIds) {
			InputDevice mInputDevice = InputDevice.getDevice(devId);
			if (mInputDevice.supportsSource(inputSource)) {
				return devId;
			}
		}
		return DEFAULT_DEVICE_ID;
	}

}
