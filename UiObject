/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.uiautomator.core;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
//import java.util.logging.Logger;

import android.graphics.Point;
import android.graphics.Rect;
import android.os.SystemClock;
import android.util.Log;
import android.view.InputDevice;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.MotionEvent.PointerCoords;
import android.view.MotionEvent.PointerProperties;
import android.view.accessibility.AccessibilityNodeInfo;

/**
 * A UiObject is a representation of a view. It is not in any way directly bound
 * to a view as an object reference. A UiObject contains information to help it
 * locate a matching view at runtime based on the {@link UiSelector} properties
 * specified in its constructor. Once you create an instance of a UiObject, it
 * can be reused for different views that match the selector criteria.
 * 
 * @since API Level 16
 */
public class UiObject {
	private static final String LOG_TAG = UiObject.class.getSimpleName();
	/**
	 * @since API Level 16
	 * @deprecated use {@link Configurator#setWaitForSelectorTimeout(long)}
	 **/
	@Deprecated
	protected static final long WAIT_FOR_SELECTOR_TIMEOUT = 10 * 1000;
	/**
	 * @since API Level 16
	 **/
	protected static final long WAIT_FOR_SELECTOR_POLL = 1000;
	// set a default timeout to 5.5s, since ANR threshold is 5s
	/**
	 * @since API Level 16
	 **/
	protected static final long WAIT_FOR_WINDOW_TMEOUT = 5500;
	/**
	 * @since API Level 16
	 **/
	protected static final int SWIPE_MARGIN_LIMIT = 5;
	/**
	 * @since API Level 17
	 * @deprecated use {@link Configurator#setScrollAcknowledgmentTimeout(long)}
	 **/
	@Deprecated
	protected static final long WAIT_FOR_EVENT_TMEOUT = 3 * 1000;
	/**
	 * @since API Level 18
	 **/
	protected static final int FINGER_TOUCH_HALF_WIDTH = 20;

	private final UiSelector mSelector;

	public final Configurator mConfig = Configurator.getInstance();

	/*
	 * 两个控件之间进行挤位操作，定义目标控件与起始控件之前的相对位置关系 2016/5/16 zwx235140
	 */
	public static final int LEFT_UP = 1;
	public static final int LEFT = 2;
	public static final int LEFT_DWON = 3;
	public static final int DOWN = 4;
	public static final int RIGHT_DOWN = 5;
	public static final int RIGHT = 6;
	public static final int RIGHT_UP = 7;
	public static final int UP = 8;

	/*
	 * 设置查找控件的模式是否为滚动模式 zwx235140 2016/4/16
	 */
	private boolean isScroll_findNodeType = true;

	public boolean isScroll_findNodeType() {
		return isScroll_findNodeType;
	}

	public void setScroll_findNodeType(boolean isScroll_findNodeType) {
		this.isScroll_findNodeType = isScroll_findNodeType;
	}

	/*
	 * add by zwx235140 存储进一步筛选node的条件，当前有before或者after 元素值用;号隔开
	 * 下标0的位置为before/after,其他为属性匹配条件
	 */
	private String conditions = "";

	/**
	 * 新增conditions，欲操作的object需要根据其二次获取
	 * 
	 * @param selector
	 * @param conditions
	 * @author zWX235140
	 */
	public UiObject(UiSelector selector, String condition) {
		mSelector = selector;
		conditions = condition;
	}

	/**
	 * Constructs a UiObject to represent a view that matches the specified
	 * selector criteria.
	 * 
	 * @param selector
	 * @since API Level 16
	 */
	public UiObject(UiSelector selector) {
		mSelector = selector;
	}

	/**
	 * Debugging helper. A test can dump the properties of a selector as a
	 * string to its logs if needed. <code>getSelector().toString();</code>
	 * 
	 * @return {@link UiSelector}
	 * @since API Level 16
	 */
	public final UiSelector getSelector() {
		Tracer.trace();
		return new UiSelector(mSelector);
	}

	/**
	 * Retrieves the {@link QueryController} to translate a {@link UiSelector}
	 * selector into an {@link AccessibilityNodeInfo}.
	 * 
	 * @return {@link QueryController}
	 */
	QueryController getQueryController() {
		return UiDevice.getInstance().getAutomatorBridge().getQueryController();
	}

	/**
	 * Retrieves the {@link InteractionController} to perform finger actions
	 * such as tapping, swiping, or entering text.
	 * 
	 * @return {@link InteractionController}
	 */
	InteractionController getInteractionController() {
		return UiDevice.getInstance().getAutomatorBridge()
				.getInteractionController();
	}

	/**
	 * Creates a new UiObject for a child view that is under the present
	 * UiObject.
	 * 
	 * @param selector
	 *            for child view to match
	 * @return a new UiObject representing the child view
	 * @since API Level 16
	 */
	public UiObject getChild(UiSelector selector)
			throws UiObjectNotFoundException {
		Tracer.trace(selector);
		return new UiObject(getSelector().childSelector(selector));
	}

	/**
	 * Creates a new UiObject for a sibling view or a child of the sibling view,
	 * relative to the present UiObject.
	 * 
	 * @param selector
	 *            for a sibling view or children of the sibling view
	 * @return a new UiObject representing the matched view
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public UiObject getFromParent(UiSelector selector)
			throws UiObjectNotFoundException {
		Tracer.trace(selector);
		return new UiObject(getSelector().fromParent(selector));
	}

	/**
	 * Counts the child views immediately under the present UiObject.
	 * 
	 * @return the count of child views.
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public int getChildCount() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		return node.getChildCount();
	}

	/**
	 * 根据滑动方式决定是否进行循环遍历查找目标控件
	 * 
	 * @author zwx235140 暂时未被调用
	 * @param timeout
	 *            in milliseconds
	 * @return AccessibilityNodeInfo if found else null
	 * @since API Level 16
	 */
	protected AccessibilityNodeInfo findAccessibilityNodeInfo1(long timeout) {
		AccessibilityNodeInfo node = null;
		long startMills = SystemClock.uptimeMillis();
		Log.d(LOG_TAG, "startMills:" + startMills);
		long currentMills = 0;
		while (currentMills <= timeout) {
			node = getQueryController()
					.findAccessibilityNodeInfo(getSelector());
			Log.d(LOG_TAG, "Traversal search node ends.");
			/*
			 * modify zwx235140 2016/4/16 原始内容为if{}里面全部
			 */
			if (isScroll_findNodeType()) {
				// 滚动查找模式
				if (node != null) {
					break;
				} else {
					// does nothing if we're reentering another runWatchers()
					UiDevice.getInstance().runWatchers();
					Log.d(LOG_TAG,
							"Traversal search node failed to find the target node");
				}
				currentMills = SystemClock.uptimeMillis() - startMills;
				if (timeout > 0) {
					SystemClock.sleep(WAIT_FOR_SELECTOR_POLL);
				}
				Log.d(LOG_TAG, "currentMills:" + currentMills);
			} else {
				// 查找节点方式为非滚动模式(就在当前屏幕布局内控件树内查找)
				break; // 遍历完成直接退出
			}

		}
		return node;
	}

	public AccessibilityNodeInfo getRootNode() {
		return getQueryController().getRootNode();
	}

	/**
	 * Finds a matching UI element in the accessibility hierarchy, by using the
	 * selector for this UiObject.
	 * 
	 * @param timeout
	 *            in milliseconds
	 * @return AccessibilityNodeInfo if found else null
	 * @since API Level 16
	 */
	protected AccessibilityNodeInfo findAccessibilityNodeInfo(long timeout) {
		AccessibilityNodeInfo node = null;
		long startMills = SystemClock.uptimeMillis();
		Log.i(LOG_TAG, "startMills:" + startMills);
		long currentMills = 0;

		if (timeout <= 0) {
			// 只遍历查找一次
			node = getQueryController()
					.findAccessibilityNodeInfo(getSelector());

		} else {
			while (currentMills <= timeout) {
				node = getQueryController().findAccessibilityNodeInfo(
						getSelector());
				if (node != null) {
					break;
				} else {
					// does nothing if we're reentering another runWatchers()
					UiDevice.getInstance().runWatchers();
					Log.d(LOG_TAG,
							"Traversal search node failed to find the target node");
				}
				currentMills = SystemClock.uptimeMillis() - startMills;
				if (timeout > 0) {
					SystemClock.sleep(WAIT_FOR_SELECTOR_POLL);
				}
				Log.d(LOG_TAG, "currentMills:" + currentMills);
			}
		}
		if (node != null) {
			Log.i(LOG_TAG, "already find node : " + node.toString());
		} else {
			Log.i(LOG_TAG, " find node is null! ");
		}

		return node;
	}

	/**
	 * 使用codition根据相对节点二次匹配获取目标node
	 * 
	 * @param node
	 * @return node
	 * @author zWX235140
	 */
	protected AccessibilityNodeInfo findNodeByafterOrbefore(
			AccessibilityNodeInfo node) {
		Log.d(LOG_TAG, "into findNodeByafterOrbefore");
		// 目标节点
		AccessibilityNodeInfo nodeInfo = null;
		String flag = "";// before or after
		// 相对节点父节点下的子节点数
		int childNodeCount = -1;
		// 记录相对节点在同一级父节点下子节点的位置
		int nodeIndex = -1;
		String[] mConditions = null;

		// 相对节点的父节点
		AccessibilityNodeInfo parentNode = node.getParent();
		Log.d(LOG_TAG, "parentNodeInfo >> " + parentNode.toString());

		if (!conditions.equals("")) {
			Log.d(LOG_TAG, "conditions >> " + conditions);
			String attributes = conditions.replace("{", "").replace("}", "");
			mConditions = attributes.split(",");
			for (int i = 0; i < mConditions.length; i++) {
				String pro = mConditions[i].toString().trim();
				String pro_key = pro.split("=")[0];
				if (pro_key.equalsIgnoreCase("flag")) {
					flag = pro.split("=")[1];// 第一位为位置标识,after or before
					break;
				}

			}

			Log.d(LOG_TAG, "flag >> " + flag);

			// 父节点下同级节点数
			childNodeCount = parentNode.getChildCount();
			Log.d(LOG_TAG, "childNodeCount >> " + childNodeCount);

			/*
			 * 首先在同一级父节点下面的同级子节点进行匹配
			 */

			if (childNodeCount > 1) {
				/*
				 * 首先认为查找的目标节点与传入的相对节点为同一个父节点下 同一个父节点下面有多个子节点
				 */
				for (int i = 0; i < childNodeCount; i++) {
					AccessibilityNodeInfo tmpNode = parentNode.getChild(i);
					if (tmpNode.toString().equals(node.toString())) {
						// 已经查询到相对节点，获取其index
						Log.d(LOG_TAG, "already find Relative node ,index " + i);
						nodeIndex = i;
						break;
					}
				}

				if (flag.equals("before")) {
					if (nodeIndex == 0) {
						Log.d(LOG_TAG,
								"Relative node index is 0,not match before!");
						// 相对节点为第一个子节点,同级节点再无before节点;进行上一级查询
						nodeInfo = findNodeByParent(node, flag, mConditions);
					} else {
						// 循环相对节点之前的同级节点进行匹配
						for (int j = 0; j < nodeIndex; j++) {
							AccessibilityNodeInfo tmpNode = parentNode
									.getChild(j);
							Log.d(LOG_TAG, "tmpNode info:" + tmpNode.toString());
							// 根据二次搜索条件匹配目标节点
							nodeInfo = isMatchNodeByCondition(tmpNode,
									mConditions, j);
							if (nodeInfo != null) {
								Log.d(LOG_TAG,
										"already find Target node by before ,index "
												+ j);
								// 已找到目标节点
								// nodeInfo = tmpNode;
								Log.d(LOG_TAG,
										"Target node Info > "
												+ nodeInfo.toString());
								break;
							} else {
								Log.d(LOG_TAG,
										"not found target node by Relative node before!");
							}
						}
					}
				} else {
					// after
					if (nodeIndex == childNodeCount - 1) {
						// 相对节点为当前父节点最后一个节点，已无after节点，需要再上一级查找
						Log.d(LOG_TAG,
								"Relative node index max,not match after!");
						nodeInfo = findNodeByParent(node, flag, mConditions);
					} else {
						// 循环相对节点之后的同级节点进行匹配
						for (int x = nodeIndex + 1; x < childNodeCount; x++) {
							AccessibilityNodeInfo tmpNode = parentNode
									.getChild(x);
							nodeInfo = isMatchNodeByCondition(tmpNode,
									mConditions, x);
							if (nodeInfo != null) {
								Log.d(LOG_TAG,
										"already find Target node by after ,index "
												+ x);
								// 找到目标节点
								// nodeInfo = tmpNode;
								Log.d(LOG_TAG,
										"Target node Info > "
												+ nodeInfo.toString());
								break;
							} else {
								Log.d(LOG_TAG,
										"not found target node by Relative node after!");
							}
						}
					}
				}

			} else {
				// 相对节点的父节点只有一个子节点（相对节点本身）或者没有子节点,进行再上一级查询
				Log.e(LOG_TAG,
						"node relative node only a subset of nodes to search the node of a higher leve");
				nodeInfo = findNodeByParent(node, flag, mConditions);
			}

			if (nodeInfo == null) {
				Log.d(LOG_TAG, "Peer node failed to find the target node!");
				nodeInfo = findNodeByParent(node, flag, mConditions);
			}
		}
		return nodeInfo;
	}

	/**
	 * 
	 * @param node
	 *            相对节点
	 * @param startIndex
	 *            查找节点的开始下标
	 * @param endIndex
	 *            查找节点的截止下标
	 * @param flag
	 *            before/after
	 * @return
	 */
	protected AccessibilityNodeInfo findNodeByParent(
			AccessibilityNodeInfo node, String flag, String[] mConditions) {
		// 同级节点未成功匹配到目标Node
		Log.d(LOG_TAG, "into findNodeByParent");
		AccessibilityNodeInfo targetNode = null;

		// 查找相对节点所在的父级节点中的索引 有可能是父节点的父节点或者父节点的父节点的父节点
		int childIndex = getNodeIndex(node);
		/*
		 * 从相对节点向上依次取三层父级节点，然后再向下依次遍历每个子节点
		 */
		AccessibilityNodeInfo parentNode = node.getParent().getParent()
				.getParent();
		if (parentNode == null) {
			Log.d(LOG_TAG, "The relative level three node has no parent node");
			// 不满足三级父节点，取两级
			parentNode = node.getParent().getParent();
		}
		Log.d(LOG_TAG, "The upper level x parent node for relative node is >> "
				+ parentNode.toString());

		int parent_parent_childCount = parentNode.getChildCount();
		Log.d(LOG_TAG, "node.parent.parent childCount:"
				+ parent_parent_childCount);
		if (flag.equals("before")) {
			if (childIndex == 0) {
				Log.d(LOG_TAG, "no before node!will find in uper level node  ");
				/*
				 * 无before节点 相对节点处于上层父级节点中的第一个节点中,再无前一级同级节点，直接在此节点或者其子节点中进行遍历查找
				 */
				AccessibilityNodeInfo tmpNode = parentNode.getChild(0);
				targetNode = isMatchNodeByCondition(tmpNode, mConditions, 0);
				if (targetNode != null) {
					Log.d(LOG_TAG,
							"already find Target node by before ,index 0");
					// 找到节点
					Log.d(LOG_TAG,
							"Target node Info > " + targetNode.toString());
					return targetNode;
				}

			} else {
				for (int i = 0; i <= childIndex; i++) {
					AccessibilityNodeInfo tmpNode = parentNode.getChild(i);
					targetNode = isMatchNodeByCondition(tmpNode, mConditions, i);
					if (targetNode != null) {
						Log.d(LOG_TAG,
								"already find Target node by before ,index "
										+ i);
						// 找到节点
						Log.d(LOG_TAG,
								"Target node Info > " + targetNode.toString());
						return targetNode;
					}
				}
			}
		} else {
			// after
			if (childIndex == parent_parent_childCount - 1) {
				Log.d(LOG_TAG, "no after node!will find in uper level node  ");
				/*
				 * 无after节点
				 * 相对节点在父级节点下的第一层节点的最后一个节点，再无后一级同级节点，直接在此节点或者其子节点中进行遍历查找
				 */
				AccessibilityNodeInfo tmpNode = parentNode
						.getChild(parent_parent_childCount - 1);
				targetNode = isMatchNodeByCondition(tmpNode, mConditions,
						childIndex);
				if (targetNode != null) {
					Log.d(LOG_TAG, "already find Target node by after ,index :"
							+ (parent_parent_childCount - 1));
					// 找到节点
					Log.d(LOG_TAG,
							"Target node Info > " + targetNode.toString());
					return targetNode;
				}

			} else {
				for (int i = childIndex; i < parent_parent_childCount; i++) {
					AccessibilityNodeInfo tmpNode = parentNode.getChild(i);
					targetNode = isMatchNodeByCondition(tmpNode, mConditions, i);
					if (targetNode != null) {
						Log.d(LOG_TAG,
								"already find Target node by after ,index " + i);
						// 找到节点
						Log.d(LOG_TAG,
								"Target node Info > " + targetNode.toString());
						return targetNode;
					}
				}
			}
		}
		return null;

	}

	/**
	 * 获取相对节点所在父节点处于其父节点中的index
	 * 
	 * @param relativeNode
	 * @return
	 */
	protected int getNodeIndex(AccessibilityNodeInfo relativeNode) {
		Log.d(LOG_TAG, "invoke getNodeIndex");
		int index = -1;
		try {
			/*
			 * 相对节点的父节点的父节点的父节点 从相对节点向上层取三级父节点
			 */
			AccessibilityNodeInfo parentNode = relativeNode.getParent()
					.getParent().getParent();
			if (parentNode == null) {
				Log.d(LOG_TAG,
						"The relative level three node has no parent node");
				// 不满足三级父节点，取两级
				parentNode = relativeNode.getParent().getParent();
			}
			Log.d(LOG_TAG,
					"relativeNode parent.parent nodeInfo:"
							+ parentNode.toString());
			int childCount = parentNode.getChildCount();
			for (int i = 0; i < childCount; i++) {
				if (parentNode.getChild(i) == null) {
					// 子节点为null
					Log.d(LOG_TAG, "The sub node is null!index: " + i);
					continue;
				} else {
					if (isMatchNodeByNode(parentNode.getChild(i), relativeNode)) {
						// Node已匹配上
						index = i;
						break;
					}
				}

			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		Log.d(LOG_TAG, "getNodeIndex ,index " + index);
		return index;
	}

	/**
	 * 使用相对节点的属性对指定的节点进行匹配
	 * 
	 * @param compareNode
	 * @param relativeNode
	 * @return
	 */
	protected boolean isMatchNodeByNode(AccessibilityNodeInfo compareNode,
			AccessibilityNodeInfo relativeNode) {
		Log.d(LOG_TAG, "into isMatchNodeByNode!");
		Log.d(LOG_TAG, "into compareNode info>>" + compareNode.toString());
		Log.d(LOG_TAG, "into relativeNode info>>" + relativeNode.toString());
		try {
			if (compareNode.toString().equals(relativeNode.toString())) {
				Log.d(LOG_TAG, "isMatchNodeByNode OK!");
				return true;
			}
			if (compareNode.getChildCount() > 0) {
				// 节点还有子节点
				for (int i = 0; i < compareNode.getChildCount(); i++) {
					if (isMatchNodeByNode(compareNode.getChild(i), relativeNode)) {
						return true;
					}
				}
			}

			return false;
		} catch (Exception e) {
			e.printStackTrace();
			return false;

		}
	}

	/**
	 * 根据预期的属性（搜索条件）对指定Node进行匹配
	 * 
	 * @param node
	 * @param condtions
	 *            [id=xxx, text = xxx, desc = xxx]
	 * @param index
	 *            传入当前节点的索引，与预期的进行比较
	 * @return
	 */
	protected AccessibilityNodeInfo isMatchNodeByCondition(
			AccessibilityNodeInfo node, String[] condtions, int index) {
		Log.d(LOG_TAG, "into isMatchNodeByCondition!");
		Log.d(LOG_TAG, "The matching node information: " + node.toString());
		Log.d(LOG_TAG, "condtions info: " + condtions.toString());
		Log.d(LOG_TAG, "condtions size: " + condtions.length);
		AccessibilityNodeInfo targetNode = null;
		// 标识传入节点与目标节点是否匹配成功
		boolean nodeFoundFlag = true;
		try {
			Map<String, String> nodeMethods = new HashMap<String, String>();
			if (nodeMethods.size() <= 0) { // 缓存属性--方法映射
				nodeMethods.put("id", "getViewIdResourceName");
				nodeMethods.put("text", "getText");
				nodeMethods.put("desc", "getContentDescription");
			}

			if (condtions.length > 0) {
				// 循环属性一一匹配
				for (int i = 0; i < condtions.length; i++) {
					String pro = condtions[i].toString().trim();
					Log.d(LOG_TAG, "pro> " + pro);
					String pro_key = pro.split("=")[0];
					String pro_value = pro.split("=")[1];

					if (!pro_key.equalsIgnoreCase("flag")) {

						/*
						 * 增加对index的处理 2016/3/11
						 */
						if (pro_key.equalsIgnoreCase("index")) {
							if (index != Integer.valueOf(pro_value)) {
								Log.d(LOG_TAG, "index match failed!");
								nodeFoundFlag = false;
							}

						} else {
							Method nodeMathod = null;
							String proResult = "";
							try {
								nodeMathod = node.getClass().getDeclaredMethod(
										nodeMethods.get(pro_key));
								nodeMathod.setAccessible(true);
								proResult = String.valueOf(nodeMathod
										.invoke(node));
							} catch (Exception e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
							Log.d(LOG_TAG, nodeMethods.get(pro_key)
									+ " invoke result :" + proResult);
							if (("id".equals(pro_key))) {
								if (!"null".equalsIgnoreCase(proResult)) {
									String[] list = proResult.split(":");
									Log.d(LOG_TAG,
											"except value: " + list.toString());
									if (list.length > 1) {
										if (!pro_value.equals(list[1])) {
											Log.d(LOG_TAG, list[1]
													+ " not equals "
													+ pro_value);
											nodeFoundFlag = false;
										}
									}
								} else {
									Log.d(LOG_TAG, "except value is null");
									nodeFoundFlag = false;
								}
							} else {
								getSelector();
								if (UiSelector.isFuzzy) {
									// 模糊匹配 针对text或者desc
									if (!proResult.toString().toLowerCase()
											.contains(pro_value.toLowerCase())) {
										nodeFoundFlag = false;
									}
								} else {
									if (!pro_value.equals(proResult)) {
										Log.d(LOG_TAG, proResult
												+ " not equals " + pro_value);
										nodeFoundFlag = false;
									}
								}
							}

						}

						if (nodeFoundFlag) {
							// 当前传入节点匹配成功
							targetNode = node;
							return targetNode;
						}
					} else {
						// flag不是作为匹配条件
						Log.d(LOG_TAG, "Ignore flag configuration");
					}

				}
				if (node.getChildCount() >= 1) {
					// 传入节点匹配失败,其节点还有子节点，进行遍历查找
					Log.d(LOG_TAG,
							"The incoming node fails, the node traversal, node number: "
									+ node.getChildCount());
					for (int i = 0; i < node.getChildCount(); i++) {

						targetNode = isMatchNodeByCondition(node.getChild(i),
								condtions, i);
						if (targetNode != null) {
							Log.d(LOG_TAG, "match node success!Node===: "
									+ targetNode.toString());
							return targetNode;
						}
					}
				}

			}

		} catch (Exception e) {
			Log.e(LOG_TAG, "MatchNodeByCondition faild! ERROR: "
					+ e.getMessage().toString());
			e.printStackTrace();
			return targetNode;
		}
		return targetNode;

	}

	/**
	 * 根据text获取控件总数
	 * 
	 * @param text
	 * @return int
	 * @author zWX235140
	 */
	public int getNodeCountByText(String text) {
		Log.d(LOG_TAG, "into getNodeCountByText ");
		Log.d(LOG_TAG, "getNodeCount ByText :" + text);
		AccessibilityNodeInfo rootNode = getQueryController().getRootNode();
		Log.d(LOG_TAG, "rootNode  info : " + rootNode.toString());
		Log.d(LOG_TAG, "rootNode  ChildCount : " + rootNode.getChildCount());
		List<AccessibilityNodeInfo> nodes = rootNode
				.findAccessibilityNodeInfosByText(text);
		Log.d(LOG_TAG, "List<AccessibilityNodeInfo> : " + nodes.toString());
		return nodes.size();
	}

	/**
	 * 根据text获取控件总数
	 * 
	 * @param text
	 * @return int
	 * @author zWX235140
	 */
	public int getNodeCountById(String Id) {
		Log.d(LOG_TAG, "into getNodeCountById ");
		Log.d(LOG_TAG, "getNodeCount ById :" + Id);
		AccessibilityNodeInfo rootNode = getQueryController().getRootNode();
		Log.d(LOG_TAG, "rootNode  info : " + rootNode.toString());
		Log.d(LOG_TAG, "rootNode  ChildCount : " + rootNode.getChildCount());
		List<AccessibilityNodeInfo> nodes = rootNode
				.findAccessibilityNodeInfosByViewId(Id);
		Log.d(LOG_TAG, "List<AccessibilityNodeInfo> : " + nodes.toString());
		return nodes.size();
	}

	/**
	 * Drags this object to a destination UiObject. The number of steps
	 * specified in your input parameter can influence the drag speed, and
	 * varying speeds may impact the results. Consider evaluating different
	 * speeds when using this method in your tests.
	 * 
	 * @param destObj
	 *            the destination UiObject.
	 * @param steps
	 *            usually 40 steps. You can increase or decrease the steps to
	 *            change the speed.
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 */
	public boolean dragTo(UiObject destObj, int steps)
			throws UiObjectNotFoundException {
		Rect srcRect = getVisibleBounds();
		Rect dstRect = destObj.getVisibleBounds();
		return getInteractionController().swipe(srcRect.centerX(),
				srcRect.centerY(), dstRect.centerX(), dstRect.centerY(), steps,
				true);
	}

	/**
	 * Drags this object to a destination UiObject. The number of steps
	 * specified in your input parameter can influence the drag speed, and
	 * varying speeds may impact the results. Consider evaluating different
	 * speeds when using this method in your tests.
	 * 
	 * @param destObj
	 *            the destination UiObject.
	 * @param steps
	 *            usually 40 steps. You can increase or decrease the steps to
	 *            change the speed.
	 * @param downTime
	 * @param upWaitTime
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 * @author zWX235140
	 */
	public boolean dragTo(UiObject destObj, int steps, Long downTime,
			Long upWaitTime) throws UiObjectNotFoundException {
		Rect srcRect = getVisibleBounds();
		Rect dstRect = destObj.getVisibleBounds();
		return getInteractionController().swipe(srcRect.centerX(),
				srcRect.centerY(), dstRect.centerX(), dstRect.centerY(), steps,
				true, downTime, upWaitTime);
	}

	/**
	 * 两个控件之间进行挤位处理
	 * 
	 * @param destObj
	 *            目标控件
	 * @param steps
	 * @param occupyType
	 *            挤位类型； 包括1、workspace(在桌面挤位) 2、folder(在文件夹内挤位) 3、dock(dock区域挤位)
	 *            主要是用来处理为dock区域挤位时的目标坐标计算
	 * @return
	 * @throws UiObjectNotFoundException
	 */
	public boolean occupyWidget(UiObject destObj, int steps, String occupyType)
			throws UiObjectNotFoundException {
		Log.d(LOG_TAG, "invoke occupyWidget");
		Rect srcRect = getVisibleBounds();
		Rect dstRect = destObj.getVisibleBounds();

		return getInteractionController().swipeOccupy(srcRect.centerX(),
				srcRect.centerY(), dstRect.centerX(), dstRect.centerY(), steps,
				dstRect.width(), dstRect.height(),
				getRelativePosition(srcRect, dstRect), occupyType);

	}

	/**
	 * 进行控件挤位操作时，获取目标控件与起始控件的位置关系
	 * 
	 * @return
	 */
	public static int getRelativePosition(Rect srcRect, Rect dstRect) {
		Log.d(LOG_TAG, "into getRelativePosition");
		int relativePosition = -1;
		// 根据两个控件的中心点坐标来计算目标控件相对于起始控件位置
		int src_center_x = srcRect.centerX();
		int src_center_y = srcRect.centerY();
		int dst_center_x = dstRect.centerX();
		int dst_center_y = dstRect.centerY();

		if (dst_center_x < src_center_x && dst_center_y < src_center_y) {
			// 目标控件位于起始控件左上方
			relativePosition = LEFT_UP;
		} else if (dst_center_x < src_center_x && dst_center_y == src_center_y) {
			// 目标控件位于起始控件左侧
			relativePosition = LEFT;
		} else if (dst_center_x < src_center_x && dst_center_y > src_center_y) {
			// 目标控件位于起始控件左下方
			relativePosition = LEFT_DWON;
		} else if (dst_center_x == src_center_x && dst_center_y > src_center_y) {
			// 目标控件位于起始控件正下方
			relativePosition = DOWN;
		} else if (dst_center_x > src_center_x && dst_center_y > src_center_y) {
			// 目标控件位于起始控件右下方
			relativePosition = RIGHT_DOWN;
		} else if (dst_center_x > src_center_x && dst_center_y == src_center_y) {
			// 目标控件位于起始控件右侧
			relativePosition = RIGHT;
		} else if (dst_center_x > src_center_x && dst_center_y < src_center_y) {
			// 目标控件位于起始控件右上方
			relativePosition = RIGHT_UP;
		} else if (dst_center_x == src_center_x && dst_center_y < src_center_y) {
			// 目标控件位于起始控件正上方
			relativePosition = UP;
		}
		Log.d(LOG_TAG, "get relativePosition: " + relativePosition);
		return relativePosition;

	}

	/**
	 * Drags this object to arbitrary coordinates. The number of steps specified
	 * in your input parameter can influence the drag speed, and varying speeds
	 * may impact the results. Consider evaluating different speeds when using
	 * this method in your tests.
	 * 
	 * @param destX
	 *            the X-axis coordinate.
	 * @param destY
	 *            the Y-axis coordinate.
	 * @param steps
	 *            usually 40 steps. You can increase or decrease the steps to
	 *            change the speed.
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 */
	public boolean dragTo(int destX, int destY, int steps)
			throws UiObjectNotFoundException {
		Rect srcRect = getVisibleBounds();
		return getInteractionController().swipe(srcRect.centerX(),
				srcRect.centerY(), destX, destY, steps, true);
	}

	/**
	 * Drags this object to arbitrary coordinates. The number of steps specified
	 * in your input parameter can influence the drag speed, and varying speeds
	 * may impact the results. Consider evaluating different speeds when using
	 * this method in your tests.
	 * 
	 * @param destX
	 *            the X-axis coordinate.
	 * @param destY
	 *            the Y-axis coordinate.
	 * @param steps
	 *            usually 40 steps. You can increase or decrease the steps to
	 *            change the speed.
	 * @param downTime
	 * @param upWaitTime
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 */
	public boolean dragTo(int destX, int destY, int steps, Long downTime,
			Long upWaitTime) throws UiObjectNotFoundException {
		Rect srcRect = getVisibleBounds();
		return getInteractionController().swipe(srcRect.centerX(),
				srcRect.centerY(), destX, destY, steps, true, downTime,
				upWaitTime);
	}

	/**
	 * Performs the swipe up action on the UiObject. See also:
	 * <ul>
	 * <li>{@link UiScrollable#scrollToBeginning(int)}</li>
	 * <li>{@link UiScrollable#scrollToEnd(int)}</li>
	 * <li>{@link UiScrollable#scrollBackward()}</li>
	 * <li>{@link UiScrollable#scrollForward()}</li>
	 * </ul>
	 * 
	 * @param steps
	 *            indicates the number of injected move steps into the system.
	 *            Steps are injected about 5ms apart. So a 100 steps may take
	 *            about 1/2 second to complete.
	 * @return true of successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean swipeUp(int steps) throws UiObjectNotFoundException {
		Tracer.trace(steps);
		Rect rect = getVisibleBounds();
		if (rect.height() <= SWIPE_MARGIN_LIMIT * 2)
			return false; // too small to swipe
		return getInteractionController().swipe(rect.centerX(),
				rect.bottom - SWIPE_MARGIN_LIMIT, rect.centerX(),
				rect.top + SWIPE_MARGIN_LIMIT, steps);
	}

	/**
	 * Performs the swipe down action on the UiObject. The swipe gesture can be
	 * performed over any surface. The targeted UI element does not need to be
	 * scrollable. See also:
	 * <ul>
	 * <li>{@link UiScrollable#scrollToBeginning(int)}</li>
	 * <li>{@link UiScrollable#scrollToEnd(int)}</li>
	 * <li>{@link UiScrollable#scrollBackward()}</li>
	 * <li>{@link UiScrollable#scrollForward()}</li>
	 * </ul>
	 * 
	 * @param steps
	 *            indicates the number of injected move steps into the system.
	 *            Steps are injected about 5ms apart. So a 100 steps may take
	 *            about 1/2 second to complete.
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean swipeDown(int steps) throws UiObjectNotFoundException {
		Tracer.trace(steps);
		Rect rect = getVisibleBounds();
		if (rect.height() <= SWIPE_MARGIN_LIMIT * 2)
			return false; // too small to swipe
		return getInteractionController().swipe(rect.centerX(),
				rect.top + SWIPE_MARGIN_LIMIT, rect.centerX(),
				rect.bottom - SWIPE_MARGIN_LIMIT, steps);
	}

	/**
	 * Performs the swipe left action on the UiObject. The swipe gesture can be
	 * performed over any surface. The targeted UI element does not need to be
	 * scrollable. See also:
	 * <ul>
	 * <li>{@link UiScrollable#scrollToBeginning(int)}</li>
	 * <li>{@link UiScrollable#scrollToEnd(int)}</li>
	 * <li>{@link UiScrollable#scrollBackward()}</li>
	 * <li>{@link UiScrollable#scrollForward()}</li>
	 * </ul>
	 * 
	 * @param steps
	 *            indicates the number of injected move steps into the system.
	 *            Steps are injected about 5ms apart. So a 100 steps may take
	 *            about 1/2 second to complete.
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean swipeLeft(int steps) throws UiObjectNotFoundException {
		Tracer.trace(steps);
		Rect rect = getVisibleBounds();
		if (rect.width() <= SWIPE_MARGIN_LIMIT * 2)
			return false; // too small to swipe
		return getInteractionController().swipe(
				rect.right - SWIPE_MARGIN_LIMIT, rect.centerY(),
				rect.left + SWIPE_MARGIN_LIMIT, rect.centerY(), steps);
	}

	/**
	 * Performs the swipe right action on the UiObject. The swipe gesture can be
	 * performed over any surface. The targeted UI element does not need to be
	 * scrollable. See also:
	 * <ul>
	 * <li>{@link UiScrollable#scrollToBeginning(int)}</li>
	 * <li>{@link UiScrollable#scrollToEnd(int)}</li>
	 * <li>{@link UiScrollable#scrollBackward()}</li>
	 * <li>{@link UiScrollable#scrollForward()}</li>
	 * </ul>
	 * 
	 * @param steps
	 *            indicates the number of injected move steps into the system.
	 *            Steps are injected about 5ms apart. So a 100 steps may take
	 *            about 1/2 second to complete.
	 * @return true if successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean swipeRight(int steps) throws UiObjectNotFoundException {
		Tracer.trace(steps);
		Rect rect = getVisibleBounds();
		if (rect.width() <= SWIPE_MARGIN_LIMIT * 2)
			return false; // too small to swipe
		return getInteractionController().swipe(rect.left + SWIPE_MARGIN_LIMIT,
				rect.centerY(), rect.right - SWIPE_MARGIN_LIMIT,
				rect.centerY(), steps);
	}

	/**
	 * Finds the visible bounds of a partially visible UI element
	 * 
	 * @param node
	 * @return null if node is null, else a Rect containing visible bounds
	 */
	public Rect getVisibleBounds(AccessibilityNodeInfo node) {
		if (node == null) {
			return null;
		}
		Log.d(LOG_TAG, "getVisibleBounds for  NodeInfo :" + node.toString());
		// targeted node's bounds
		int w = UiDevice.getInstance().getDisplayWidth();
		int h = UiDevice.getInstance().getDisplayHeight();
		Rect nodeRect = AccessibilityNodeInfoHelper.getVisibleBoundsInScreen(
				node, w, h);
		// is the targeted node within a scrollable container?
		AccessibilityNodeInfo scrollableParentNode = getScrollableParent(node);
		if (scrollableParentNode == null) {
			// nothing to adjust for so return the node's Rect as is
			return nodeRect;
		}

		// Scrollable parent's visible bounds
		Rect parentRect = AccessibilityNodeInfoHelper.getVisibleBoundsInScreen(
				scrollableParentNode, w, h);
		// adjust for partial clipping of targeted by parent node if required
		nodeRect.intersect(parentRect);
		return nodeRect;
	}

	/**
	 * Walks up the layout hierarchy to find a scrollable parent. A scrollable
	 * parent indicates that this node might be in a container where it is
	 * partially visible due to scrolling. In this case, its clickable center
	 * might not be visible and the click coordinates should be adjusted.
	 * 
	 * @param node
	 * @return The accessibility node info.
	 */
	private AccessibilityNodeInfo getScrollableParent(AccessibilityNodeInfo node) {
		AccessibilityNodeInfo parent = node;
		while (parent != null) {
			parent = parent.getParent();
			if (parent != null && parent.isScrollable()) {
				return parent;
			}
		}
		return null;
	}

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject.
	 * 
	 * @return true id successful else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean click() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickAndSync(rect.centerX(),
				rect.centerY(), mConfig.getActionAcknowledgmentTimeout());
	}

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject.
	 * 
	 * @param downtime
	 *            click down time
	 * @return true id successful else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean click(long downtime) throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickAndSync(rect.centerX(),
				rect.centerY(), mConfig.getActionAcknowledgmentTimeout(),
				downtime);
	}

	/**
	 * 检查目标控件是否存在
	 * 
	 * @return
	 * @throws UiObjectNotFoundException
	 * @author zWX235140 2016-1-28
	 */
	public boolean checkNodeIsExsit() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		if (node != null) {
			return true;
		}
		return false;

	}

	/**
	 * 鐐瑰嚮鎺т欢锛堝紓姝ワ級
	 * 
	 * @return
	 * @throws UiObjectNotFoundException
	 */
	public boolean clickNoSyc() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickNoSync(rect.centerX(),
				rect.centerY());
	}

	/**
	 * 桌面操作：一只手长按图标，另外一只手滑动 适用于以下场景： 1、桌面上一手按图标，一手滑动 2、桌面编辑态下，一手按图标，一手滑动
	 * 3、文件夹内一手按图标，一手滑动
	 * 
	 * @param swipePages
	 *            滑动屏幕页数
	 * @param swipeOrders
	 *            依次滑动方向顺序集合。 同时支持滑动的过程中方向不受限制，如长按图标后，先向左滑动，然后向右滑动。 [true, true,
	 *            false, false] true---向左滑 false---向右滑 每项值涉及的滑动都会划过一屏
	 * 
	 * @throws UiObjectNotFoundException
	 * @author zWX235140 20160818
	 */
	public void mockOnLongClickAndAnotherSwipe(int swipePages,
			List<Boolean> swipeOrders) throws UiObjectNotFoundException {
		Log.i(LOG_TAG, "invoke mockOnLongClickAndAnotherSwipe.");
		Tracer.trace();

		// 整体思路是模拟单手长按，然后模拟多指

		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);

		float longClickX = rect.centerX();// 需要移动应用的图标坐标X
		float longClickY = rect.centerY();// 需要移动应用的图标坐标Y

		PointerProperties[] justLongClickPointerProperties = new PointerProperties[1];// 单点触控
		PointerProperties justLongClickPP = new PointerProperties();// 长按手指id及类型
		justLongClickPP.id = 0;
		justLongClickPP.toolType = MotionEvent.TOOL_TYPE_FINGER;
		justLongClickPointerProperties[0] = justLongClickPP;

		PointerCoords[] justLongClickDownPointerCoords = new PointerCoords[1];// 长按手指
		PointerCoords justLongClickDownPC = new PointerCoords();
		justLongClickDownPC.x = longClickX;
		justLongClickDownPC.y = longClickY;
		justLongClickDownPC.pressure = 1;
		justLongClickDownPC.size = 1.0f;
		justLongClickDownPointerCoords[0] = justLongClickDownPC;

		long downTime = SystemClock.uptimeMillis();
		// 长按图标开始
		MotionEvent longClickDown = MotionEvent.obtain(downTime,
				SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN,
				/* pointerCount */1, /* pointerProperties */
				justLongClickPointerProperties, /* pointerCoords */
				justLongClickDownPointerCoords,
				/* metaState */0, /* buttonState */0,/* xPrecision */1.0f, /* yPrecision */
				1.0f, /* deviceId */0, /* edgeFlags */0,
				/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */0);
		getInteractionController().injectEventSync(longClickDown);

		for (int i = 0; i < 20; i++) {// 对图标进行长按
			MotionEvent longClickMove = MotionEvent.obtain(downTime,
					SystemClock.uptimeMillis(), MotionEvent.ACTION_MOVE,
					/* pointerCount */1, /* pointerProperties */
					justLongClickPointerProperties, /* pointerCoords */
					justLongClickDownPointerCoords,
					/* metaState */0, /* buttonState */0,/* xPrecision */1.0f, /* yPrecision */
					1.0f, /* deviceId */0, /* edgeFlags */0,
					/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */0);
			getInteractionController().injectEventSync(longClickMove);
			SystemClock.sleep(50);
		}

		PointerProperties[] longClickAndSwipePointerProperties = new PointerProperties[2];// 双指
		PointerProperties swipePP = new PointerProperties();// 滑动手指的id及类型
		swipePP.id = 1;
		swipePP.toolType = MotionEvent.TOOL_TYPE_FINGER;
		longClickAndSwipePointerProperties[0] = justLongClickPP;// 长按的手指
		longClickAndSwipePointerProperties[1] = swipePP;// 滑动的手指

		// int swipePagess = swipePages;// 滑动的页数
		// 用于指示桌面向左滑还是向右滑
		// true---向左滑
		// false---向右滑
		// boolean[] toLeft = { true, true, false, false };

		float rightToLeftSwipeStartX = 900.0f;// 向左滑的起始位置
		float leftToRightSwipeStartX = 100.0f;// 向右滑的起始位置
		int swipeSteps = 9;

		PointerCoords[] longClickDownAndSwipePointerCoords = new PointerCoords[2];// 多指
		PointerCoords swipeDownPC = new PointerCoords();
		swipeDownPC.x = swipeOrders.get(0) ? rightToLeftSwipeStartX
				: leftToRightSwipeStartX;
		swipeDownPC.y = 950.0f;
		swipeDownPC.pressure = 1;
		swipeDownPC.size = 1.0f;
		longClickDownAndSwipePointerCoords[0] = justLongClickDownPC;// 长按的手指
		longClickDownAndSwipePointerCoords[1] = swipeDownPC;// 滑动的手指按下

		for (int index = 0; index < swipePages; index++) {// 支持多页的滑动

			MotionEvent longClickAndSwipeDown = MotionEvent.obtain(downTime,
					SystemClock.uptimeMillis(), /* POINTER_DOWN */261,
					/* pointerCount */2, /* pointerProperties */
					longClickAndSwipePointerProperties, /* pointerCoords */
					longClickDownAndSwipePointerCoords,
					/* metaState */0, /* buttonState */0,/* xPrecision */1.0f, /* yPrecision */
					1.0f, /* deviceId */0, /* edgeFlags */0,
					/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */0);
			getInteractionController().injectEventSync(longClickAndSwipeDown);

			PointerCoords swipeMovePC = null;
			for (int step = 0; step < swipeSteps; step++) {// 开始滑动页面

				swipeMovePC = new PointerCoords();
				if (swipeOrders.size() == 1) {// 默认情况下，在整个滑动的过程中只是朝一个方向滑动
					swipeMovePC.x = swipeOrders.get(0) ? (rightToLeftSwipeStartX - 100 * step)
							: (leftToRightSwipeStartX + 100 * step);
				} else {// 在滑动的整个过程中有方向的变化，如先向左做滑动，然后又向右滑动,此时必须指定每一次滑动方向
					swipeMovePC.x = swipeOrders.get(index) ? (rightToLeftSwipeStartX - 100 * step)
							: (leftToRightSwipeStartX + 100 * step);
				}
				swipeMovePC.y = 950.0f;
				swipeMovePC.pressure = 1;
				swipeMovePC.size = 1.0f;
				longClickDownAndSwipePointerCoords[1] = swipeMovePC;// 滑动的手指开始滑动

				MotionEvent moveEvent = MotionEvent.obtain(downTime,
						SystemClock.uptimeMillis(), MotionEvent.ACTION_MOVE,
						/* pointerCount */2, /* pointerProperties */
						longClickAndSwipePointerProperties, /* pointerCoords */
						longClickDownAndSwipePointerCoords,
						/* metaState */0, /* buttonState */0,/* xPrecision */
						1.0f, /* yPrecision */1.0f, /* deviceId */0, /* edgeFlags */
						0,
						/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */
						0);
				getInteractionController().injectEventSync(moveEvent);
			}

			PointerCoords swipeUpPC = new PointerCoords();// 一次滑动完成
			swipeUpPC.x = swipeMovePC.x;
			swipeUpPC.y = 950.0f;
			swipeUpPC.pressure = 1;
			swipeUpPC.size = 1.0f;
			longClickDownAndSwipePointerCoords[1] = swipeUpPC;

			MotionEvent longClickAndSwipeUp = MotionEvent.obtain(downTime,
					SystemClock.uptimeMillis(), /* POINTER_UP */262,
					/* pointerCount */2, /* pointerProperties */
					longClickAndSwipePointerProperties, /* pointerCoords */
					longClickDownAndSwipePointerCoords,
					/* metaState */0, /* buttonState */0,/* xPrecision */1.0f, /* yPrecision */
					1.0f, /* deviceId */0, /* edgeFlags */0,
					/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */0);
			getInteractionController().injectEventSync(longClickAndSwipeUp);
			SystemClock.sleep(400L);// 必要的延时，等待页面滑动完成，否则图标落地位置不对
		}

		// 整体结束
		MotionEvent longClickUp = MotionEvent.obtain(downTime,
				SystemClock.uptimeMillis(), MotionEvent.ACTION_UP,
				/* pointerCount */1, /* pointerProperties */
				justLongClickPointerProperties, /* pointerCoords */
				justLongClickDownPointerCoords,
				/* metaState */0, /* buttonState */0,/* xPrecision */1.0f, /* yPrecision */
				1.0f, /* deviceId */0, /* edgeFlags */0,
				/* source */InputDevice.SOURCE_TOUCHSCREEN, /* flags */0);
		getInteractionController().injectEventSync(longClickUp);
	}

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject.
	 * 
	 * @return true id successful else false
	 * @param downtime
	 *            click down time
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickNoSyc(long downtime) throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickNoSync(rect.centerX(),
				rect.centerY(), downtime);
	}

	/**
	 * Waits for window transitions that would typically take longer than the
	 * usual default timeouts. See {@link #clickAndWaitForNewWindow(long)}
	 * 
	 * @return true if the event was triggered, else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickAndWaitForNewWindow() throws UiObjectNotFoundException {
		Tracer.trace();
		return clickAndWaitForNewWindow(WAIT_FOR_WINDOW_TMEOUT);
	}

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject and waits for window transitions.
	 * 
	 * This method differ from {@link UiObject#click()} only in that this method
	 * waits for a a new window transition as a result of the click. Some
	 * examples of a window transition: <li>launching a new activity</li> <li>
	 * bringing up a pop-up menu</li> <li>bringing up a dialog</li>
	 * 
	 * @param timeout
	 *            timeout before giving up on waiting for a new window
	 * @return true if the event was triggered, else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickAndWaitForNewWindow(long timeout)
			throws UiObjectNotFoundException {
		Tracer.trace(timeout);
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickAndWaitForNewWindow(
				rect.centerX(), rect.centerY(),
				mConfig.getActionAcknowledgmentTimeout());
	}

	/**
	 * Clicks the top and left corner of the UI element
	 * 
	 * @return true on success
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickTopLeft() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickNoSync(rect.left + 5,
				rect.top + 5);
	}

	/**
	 * Long clicks bottom and right corner of the UI element
	 * 
	 * @return true if operation was successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean longClickBottomRight() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().longTapNoSync(rect.right - 5,
				rect.bottom - 5);
	}

	/**
	 * Clicks the bottom and right corner of the UI element
	 * 
	 * @return true on success
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickBottomRight() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickNoSync(rect.right - 5,
				rect.bottom - 5);
	}

	/**
	 * Long clicks the center of the visible bounds of the UI element
	 * 
	 * @return true if operation was successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean longClick() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		Rect rect = getVisibleBounds(node);
		return getInteractionController().longTapNoSync(rect.centerX(),
				rect.centerY());
	}

	/**
	 * Long clicks on the top and left corner of the UI element
	 * 
	 * @return true if operation was successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean longClickTopLeft() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().longTapNoSync(rect.left + 5,
				rect.top + 5);
	}

	/**
	 * Reads the <code>text</code> property of the UI element
	 * 
	 * @return text value of the current node represented by this UiObject
	 * @throws UiObjectNotFoundException
	 *             if no match could be found
	 * @since API Level 16
	 */
	public String getText() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}
		String retVal = safeStringReturn(node.getText());
		Log.d(LOG_TAG, String.format("getText() = %s", retVal));
		return retVal;
	}

	/**
	 * add by zwx23140
	 * 
	 * @return
	 * @throws UiObjectNotFoundException
	 */
	public String getDesc() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}
		String retVal = safeStringReturn(node.getContentDescription());
		Log.d(LOG_TAG, String.format("getDesc() = %s", retVal));
		return retVal;
	}

	/**
	 * Retrieves the <code>className</code> property of the UI element.
	 * 
	 * @return class name of the current node represented by this UiObject
	 * @throws UiObjectNotFoundException
	 *             if no match was found
	 * @since API Level 18
	 */
	public String getClassName() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		String retVal = safeStringReturn(node.getClassName());
		Log.d(LOG_TAG, String.format("getClassName() = %s", retVal));
		return retVal;
	}

	/**
	 * Reads the <code>content_desc</code> property of the UI element
	 * 
	 * @return value of node attribute "content_desc"
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public String getContentDescription() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}
		return safeStringReturn(node.getContentDescription());
	}

	/**
	 * Sets the text in an editable field, after clearing the field's content.
	 * 
	 * The {@link UiSelector} selector of this object must reference a UI
	 * element that is editable.
	 * 
	 * When you call this method, the method first simulates a {@link #click()}
	 * on editable field to set focus. The method then clears the field's
	 * contents and injects your specified text into the field.
	 * 
	 * If you want to capture the original contents of the field, call
	 * {@link #getText()} first. You can then modify the text and use this
	 * method to update the field.
	 * 
	 * @param text
	 *            string to set
	 * @return true if operation is successful
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean setText(String text) throws UiObjectNotFoundException {
		Tracer.trace(text);
		clearTextField();
		return getInteractionController().sendText(text);
	}

	/**
	 * Clears the existing text contents in an editable field.
	 * 
	 * The {@link UiSelector} of this object must reference a UI element that is
	 * editable.
	 * 
	 * When you call this method, the method first sets focus at the start edge
	 * of the field. The method then simulates a long-press to select the
	 * existing text, and deletes the selected text.
	 * 
	 * If a "Select-All" option is displayed, the method will automatically
	 * attempt to use it to ensure full text selection.
	 * 
	 * Note that it is possible that not all the text in the field is selected;
	 * for example, if the text contains separators such as spaces, slashes, at
	 * symbol etc. Also, not all editable fields support the long-press
	 * functionality.
	 * 
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public void clearTextField() throws UiObjectNotFoundException {
		Tracer.trace();
		// long click left + center
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Rect rect = getVisibleBounds(node);
		getInteractionController()
				.longTapNoSync(rect.left + 20, rect.centerY());
		// check if the edit menu is open
		UiObject selectAll = new UiObject(
				new UiSelector().descriptionContains("Select all"));
		if (selectAll.waitForExists(50))
			selectAll.click();
		// wait for the selection
		SystemClock.sleep(250);
		// delete it
		getInteractionController().sendKey(KeyEvent.KEYCODE_DEL, 0);
	}

	/**
	 * Check if the UI element's <code>checked</code> property is currently true
	 * 
	 * @return true if it is else false
	 * @since API Level 16
	 */
	public boolean isChecked() throws UiObjectNotFoundException {

		Log.d(LOG_TAG, "into isChecked()!!!");
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		Log.d(LOG_TAG, "conditions:" + conditions);
		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isChecked();
	}

	/**
	 * Checks if the UI element's <code>selected</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isSelected() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isSelected();
	}

	/**
	 * Checks if the UI element's <code>password</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 * @author zWX235140
	 */
	public boolean isPassword() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isPassword();
	}

	/**
	 * Checks if the UI element's <code>checkable</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isCheckable() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isCheckable();
	}

	/**
	 * Checks if the UI element's <code>enabled</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isEnabled() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isEnabled();
	}

	/**
	 * Checks if the UI element's <code>clickable</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isClickable() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isClickable();
	}

	/**
	 * Check if the UI element's <code>focused</code> property is currently true
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isFocused() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isFocused();
	}

	/**
	 * Check if the UI element's <code>focusable</code> property is currently
	 * true.
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isFocusable() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isFocusable();
	}

	/**
	 * Check if the view's <code>scrollable</code> property is currently true
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isScrollable() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isScrollable();
	}

	/**
	 * Check if the view's <code>long-clickable</code> property is currently
	 * true
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean isLongClickable() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		return node.isLongClickable();
	}

	/**
	 * Reads the view's <code>package</code> property
	 * 
	 * @return true if it is else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public String getPackageName() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		return safeStringReturn(node.getPackageName());
	}

	/**
	 * Returns the visible bounds of the view.
	 * 
	 * If a portion of the view is visible, only the bounds of the visible
	 * portion are reported.
	 * 
	 * @return Rect
	 * @throws UiObjectNotFoundException
	 * @see {@link #getBounds()}
	 * @since API Level 17
	 */
	public Rect getVisibleBounds() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}
		return getVisibleBounds(node);
	}

	/**
	 * Returns the view's <code>bounds</code> property. See
	 * {@link #getVisibleBounds()}
	 * 
	 * @return Rect
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public Rect getBounds() throws UiObjectNotFoundException {
		Tracer.trace();
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		if (!conditions.equals("")) {
			node = findNodeByafterOrbefore(node);
		}

		Rect nodeRect = new Rect();
		node.getBoundsInScreen(nodeRect);

		return nodeRect;
	}

	/**
	 * Waits a specified length of time for a view to become visible.
	 * 
	 * This method waits until the view becomes visible on the display, or until
	 * the timeout has elapsed. You can use this method in situations where the
	 * content that you want to select is not immediately displayed.
	 * 
	 * @param timeout
	 *            the amount of time to wait (in milliseconds)
	 * @return true if the view is displayed, else false if timeout elapsed
	 *         while waiting
	 * @since API Level 16
	 */
	public boolean waitForExists(long timeout) {
		Tracer.trace(timeout);
		if (findAccessibilityNodeInfo(timeout) != null) {
			return true;
		}
		return false;
	}

	/**
	 * Waits a specified length of time for a view to become undetectable.
	 * 
	 * This method waits until a view is no longer matchable, or until the
	 * timeout has elapsed.
	 * 
	 * A view becomes undetectable when the {@link UiSelector} of the object is
	 * unable to find a match because the element has either changed its state
	 * or is no longer displayed.
	 * 
	 * You can use this method when attempting to wait for some long operation
	 * to compete, such as downloading a large file or connecting to a remote
	 * server.
	 * 
	 * @param timeout
	 *            time to wait (in milliseconds)
	 * @return true if the element is gone before timeout elapsed, else false if
	 *         timeout elapsed but a matching element is still found.
	 * @since API Level 16
	 */
	public boolean waitUntilGone(long timeout) {
		Tracer.trace(timeout);
		long startMills = SystemClock.uptimeMillis();
		long currentMills = 0;
		while (currentMills <= timeout) {
			if (findAccessibilityNodeInfo(0) == null)
				return true;
			currentMills = SystemClock.uptimeMillis() - startMills;
			if (timeout > 0)
				SystemClock.sleep(WAIT_FOR_SELECTOR_POLL);
		}
		return false;
	}

	/**
	 * Check if view exists.
	 * 
	 * This methods performs a {@link #waitForExists(long)} with zero timeout.
	 * This basically returns immediately whether the view represented by this
	 * UiObject exists or not. If you need to wait longer for this view, then
	 * see {@link #waitForExists(long)}.
	 * 
	 * @return true if the view represented by this UiObject does exist
	 * @since API Level 16
	 */
	public boolean exists() {
		Tracer.trace();
		return waitForExists(0);
	}

	private String safeStringReturn(CharSequence cs) {
		if (cs == null)
			return "";
		return cs.toString();
	}

	/**
	 * Performs a two-pointer gesture, where each pointer moves diagonally
	 * opposite across the other, from the center out towards the edges of the
	 * this UiObject.
	 * 
	 * @param percent
	 *            percentage of the object's diagonal length for the pinch
	 *            gesture
	 * @param steps
	 *            the number of steps for the gesture. Steps are injected about
	 *            5 milliseconds apart, so 100 steps may take around 0.5 seconds
	 *            to complete.
	 * @return <code>true</code> if all touch events for this gesture are
	 *         injected successfully, <code>false</code> otherwise
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 */
	public boolean pinchOut(int percent, int steps)
			throws UiObjectNotFoundException {
		// make value between 1 and 100
		percent = (percent < 0) ? 1 : (percent > 100) ? 100 : percent;
		float percentage = percent / 100f;

		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		Rect rect = getVisibleBounds(node);
		if (rect.width() <= FINGER_TOUCH_HALF_WIDTH * 2)
			throw new IllegalStateException(
					"Object width is too small for operation");

		// start from the same point at the center of the control
		Point startPoint1 = new Point(rect.centerX() - FINGER_TOUCH_HALF_WIDTH,
				rect.centerY());
		Point startPoint2 = new Point(rect.centerX() + FINGER_TOUCH_HALF_WIDTH,
				rect.centerY());

		// End at the top-left and bottom-right corners of the control
		Point endPoint1 = new Point(rect.centerX()
				- (int) ((rect.width() / 2) * percentage), rect.centerY());
		Point endPoint2 = new Point(rect.centerX()
				+ (int) ((rect.width() / 2) * percentage), rect.centerY());

		return performTwoPointerGesture(startPoint1, startPoint2, endPoint1,
				endPoint2, steps);
	}

	/**
	 * Performs a two-pointer gesture, where each pointer moves diagonally
	 * toward the other, from the edges to the center of this UiObject .
	 * 
	 * @param percent
	 *            percentage of the object's diagonal length for the pinch
	 *            gesture
	 * @param steps
	 *            the number of steps for the gesture. Steps are injected about
	 *            5 milliseconds apart, so 100 steps may take around 0.5 seconds
	 *            to complete.
	 * @return <code>true</code> if all touch events for this gesture are
	 *         injected successfully, <code>false</code> otherwise
	 * @throws UiObjectNotFoundException
	 * @since API Level 18
	 */
	public boolean pinchIn(int percent, int steps)
			throws UiObjectNotFoundException {
		// make value between 1 and 100
		percent = (percent < 0) ? 0 : (percent > 100) ? 100 : percent;
		float percentage = percent / 100f;

		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		if (node == null) {
			throw new UiObjectNotFoundException(getSelector().toString());
		}

		Rect rect = getVisibleBounds(node);
		if (rect.width() <= FINGER_TOUCH_HALF_WIDTH * 2)
			throw new IllegalStateException(
					"Object width is too small for operation");

		Point startPoint1 = new Point(rect.centerX()
				- (int) ((rect.width() / 2) * percentage), rect.centerY());
		Point startPoint2 = new Point(rect.centerX()
				+ (int) ((rect.width() / 2) * percentage), rect.centerY());

		Point endPoint1 = new Point(rect.centerX() - FINGER_TOUCH_HALF_WIDTH,
				rect.centerY());
		Point endPoint2 = new Point(rect.centerX() + FINGER_TOUCH_HALF_WIDTH,
				rect.centerY());

		return performTwoPointerGesture(startPoint1, startPoint2, endPoint1,
				endPoint2, steps);
	}

	/**
	 * Generates a two-pointer gesture with arbitrary starting and ending
	 * points.
	 * 
	 * @param startPoint1
	 *            start point of pointer 1
	 * @param startPoint2
	 *            start point of pointer 2
	 * @param endPoint1
	 *            end point of pointer 1
	 * @param endPoint2
	 *            end point of pointer 2
	 * @param steps
	 *            the number of steps for the gesture. Steps are injected about
	 *            5 milliseconds apart, so 100 steps may take around 0.5 seconds
	 *            to complete.
	 * @return <code>true</code> if all touch events for this gesture are
	 *         injected successfully, <code>false</code> otherwise
	 * @since API Level 18
	 */
	public boolean performTwoPointerGesture(Point startPoint1,
			Point startPoint2, Point endPoint1, Point endPoint2, int steps) {

		// avoid a divide by zero
		if (steps == 0)
			steps = 1;

		final float stepX1 = (endPoint1.x - startPoint1.x) / steps;
		final float stepY1 = (endPoint1.y - startPoint1.y) / steps;
		final float stepX2 = (endPoint2.x - startPoint2.x) / steps;
		final float stepY2 = (endPoint2.y - startPoint2.y) / steps;

		int eventX1, eventY1, eventX2, eventY2;
		eventX1 = startPoint1.x;
		eventY1 = startPoint1.y;
		eventX2 = startPoint2.x;
		eventY2 = startPoint2.y;

		// allocate for steps plus first down and last up
		PointerCoords[] points1 = new PointerCoords[steps + 2];
		PointerCoords[] points2 = new PointerCoords[steps + 2];

		// Include the first and last touch downs in the arrays of steps
		for (int i = 0; i < steps + 1; i++) {
			PointerCoords p1 = new PointerCoords();
			p1.x = eventX1;
			p1.y = eventY1;
			p1.pressure = 1;
			p1.size = 1;
			points1[i] = p1;

			PointerCoords p2 = new PointerCoords();
			p2.x = eventX2;
			p2.y = eventY2;
			p2.pressure = 1;
			p2.size = 1;
			points2[i] = p2;

			eventX1 += stepX1;
			eventY1 += stepY1;
			eventX2 += stepX2;
			eventY2 += stepY2;
		}

		// ending pointers coordinates
		PointerCoords p1 = new PointerCoords();
		p1.x = endPoint1.x;
		p1.y = endPoint1.y;
		p1.pressure = 1;
		p1.size = 1;
		points1[steps + 1] = p1;

		PointerCoords p2 = new PointerCoords();
		p2.x = endPoint2.x;
		p2.y = endPoint2.y;
		p2.pressure = 1;
		p2.size = 1;
		points2[steps + 1] = p2;

		return performMultiPointerGesture(points1, points2);
	}

	/**
	 * Performs a multi-touch gesture. You must specify touch coordinates for at
	 * least 2 pointers. Each pointer must have all of its touch steps defined
	 * in an array of {@link PointerCoords}. You can use this method to specify
	 * complex gestures, like circles and irregular shapes, where each pointer
	 * may take a different path.
	 * 
	 * To create a single point on a pointer's touch path: <code>
	 *       PointerCoords p = new PointerCoords();
	 *       p.x = stepX;
	 *       p.y = stepY;
	 *       p.pressure = 1;
	 *       p.size = 1;
	 * </code>
	 * 
	 * @param touches
	 *            represents the pointers' paths. Each {@link PointerCoords}
	 *            array represents a different pointer. Each
	 *            {@link PointerCoords} in an array element represents a touch
	 *            point on a pointer's path.
	 * @return <code>true</code> if all touch events for this gesture are
	 *         injected successfully, <code>false</code> otherwise
	 * @since API Level 18
	 */
	public boolean performMultiPointerGesture(PointerCoords[]... touches) {
		return getInteractionController().performMultiPointerGesture(touches);
	}

	/**
	 * 根据父子节点关系进行点击
	 * 
	 * @param relativePath
	 *            parent.children[1].children[10]
	 * @author zwx235140
	 * @return
	 */
	public String clickParentChildNode(String relativePath) {
		Log.i(LOG_TAG, "into clickParentChildNode.");
		boolean result;
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());// 获取根节点
		Log.i(LOG_TAG, "Object node info : " + node.toString());
		String parent = relativePath.substring(0,
				relativePath.indexOf("children") - 1);
		Log.d(LOG_TAG, "parent:" + parent);
		String child = relativePath.substring(relativePath.indexOf("children"));
		Log.d(LOG_TAG, "child:" + child);
		String[] arrayParent = parent.split("\\.");
		String[] arrayChild = child.split("\\.");
		// 循环选取父节点
		for (int i = 0; i < arrayParent.length; i++) {
			if (node != null) {
				node = node.getParent();
				Log.d(LOG_TAG, "Object  Parent node info : " + node.toString());
				Log.d(LOG_TAG,
						"Object  Parent' children node count : "
								+ node.getChildCount());

			}
		}
		// 循环选取子节点
		for (int j = 0; j < arrayChild.length; j++) {
			int childNum = 0;
			Log.d(LOG_TAG, "calc childNum");
			// 每个children[x]目前支持的取值范围为0-99
			if (arrayChild[j].length() == 11) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 10));
			} else if (arrayChild[j].length() == 12) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 11));
			} else {
				Log.d(LOG_TAG,
						"children[xx] current support node size is [0,99]");
				return "children[xx] current support node size is [0,99]";
			}
			Log.d(LOG_TAG, "childNum:" + childNum);
			// SparseLongArray mChildNodeIds = node.getChildNodeIds();
			// Log.d(LOG_TAG,"mChildNodeIds info : " +
			// mChildNodeIds.toString());
			// Log.d(LOG_TAG, "mChildNodeIds.get(childNum)" +
			// mChildNodeIds.get(childNum));
			if (node != null) {
				node = node.getChild(childNum);
				Log.i(LOG_TAG,
						"Object  children node info : " + node.toString());

			}
		}

		Log.i(LOG_TAG, "target node is geted!");
		Rect rect = getVisibleBounds(node);
		Log.d(LOG_TAG, "X:" + rect.centerX() + "; y : " + rect.centerY());
		result = getInteractionController().clickNoSync(rect.centerX(),
				rect.centerY());
		/*
		 * clickAndSync(rect.centerX(), rect.centerY(),
		 * mConfig.getActionAcknowledgmentTimeout() );
		 */
		if (result == false) {
			return "false,click failed-point:[" + rect.centerX() + ","
					+ rect.centerY() + "]";
		} else {
			return "true";
		}

	}

	/**
	 * 根据父子节点关系获取控件类型
	 * 
	 * @param relativePath
	 *            parent.children[1].children[10]
	 * @author zwx235140
	 * @return
	 */
	public String getClassNameByRelativepath(String relativePath) {
		Log.d(LOG_TAG, "invoke getClassNameByRelativepath. relativePath: "
				+ relativePath);
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());// 获取相对节点
		Log.d(LOG_TAG, "Object node info : " + node.toString());
		String parent = relativePath.substring(0,
				relativePath.indexOf("children") - 1);
		Log.d(LOG_TAG, "parent:" + parent);
		String child = relativePath.substring(relativePath.indexOf("children"));
		Log.d(LOG_TAG, "child:" + child);
		String[] arrayParent = parent.split("\\.");
		String[] arrayChild = child.split("\\.");
		// 循环选取父节点
		for (int i = 0; i < arrayParent.length; i++) {
			if (node != null) {
				node = node.getParent();
				Log.d(LOG_TAG, "Object  Parent node info : " + node.toString());
				Log.d(LOG_TAG,
						"Object  Parent' children node count : "
								+ node.getChildCount());

			}
		}
		// 循环选取子节点
		for (int j = 0; j < arrayChild.length; j++) {
			int childNum = 0;
			Log.d(LOG_TAG, "calc childNum");
			// 每个children[x]目前支持的取值范围为0-99
			if (arrayChild[j].length() == 11) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 10));
			} else if (arrayChild[j].length() == 12) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 11));
			} else {
				Log.d(LOG_TAG,
						"children[xx] current support node size is [0,99]");
				return "children[xx] current support node size is [0,99]";
			}
			Log.d(LOG_TAG, "childNum:" + childNum);
			if (node != null) {
				node = node.getChild(childNum);
				Log.d(LOG_TAG,
						"Object  children node info : " + node.toString());

			}
		}

		String retVal = safeStringReturn(node.getClassName());
		Log.d(LOG_TAG, String.format("getClassName() = %s", retVal));
		return retVal;

	}

	/**
	 * 鏍规嵁鐖跺瓙鑺傜偣妫�煡check鎺т欢
	 * 
	 * @param relativePath
	 * @author n00221817
	 * @return
	 */
	public String isCheckedByRelativePath(String relativePath) {
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());// 获取根节点
		Log.d(LOG_TAG, "Object node info : " + node.toString());
		String parent = relativePath.substring(0,
				relativePath.indexOf("children") - 1);
		Log.d(LOG_TAG, "parent:" + parent);
		String child = relativePath.substring(relativePath.indexOf("children"));
		Log.d(LOG_TAG, "child:" + child);
		String[] arrayParent = parent.split("\\.");
		String[] arrayChild = child.split("\\.");
		// 循环选取父节点
		for (int i = 0; i < arrayParent.length; i++) {
			if (node != null) {
				node = node.getParent();
				Log.d(LOG_TAG, "Object  Parent node info : " + node.toString());
				Log.d(LOG_TAG,
						"Object  Parent' children node count : "
								+ node.getChildCount());

			}
		}
		// 循环选取子节点
		for (int j = 0; j < arrayChild.length; j++) {
			int childNum = 0;
			Log.d(LOG_TAG, "calc childNum");
			// 每个children[x]目前支持的取值范围为0-99
			if (arrayChild[j].length() == 11) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 10));
			} else if (arrayChild[j].length() == 12) {
				childNum = Integer.parseInt(arrayChild[j].substring(9, 11));
			} else {
				Log.d(LOG_TAG,
						"children[xx] current support node size is [0,99]");
				return "children[xx] current support node size is [0,99]";
			}
			Log.d(LOG_TAG, "childNum:" + childNum);
			// SparseLongArray mChildNodeIds = node.getChildNodeIds();
			// Log.d(LOG_TAG,"mChildNodeIds info : " +
			// mChildNodeIds.toString());
			// Log.d(LOG_TAG, "mChildNodeIds.get(childNum)" +
			// mChildNodeIds.get(childNum));
			if (node != null) {
				node = node.getChild(childNum);
				Log.d(LOG_TAG,
						"Object  children node info : " + node.toString());

			}
		}

		if (node.isCheckable()) {
			if (node.isChecked()) {
				return "true";
			} else {
				return "false";
			}
		} else {
			return "false,non Checkable widget,please check it";
		}
	}

	public String getTextByRelativePath(String relativePath) {
		AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
				.getWaitForSelectorTimeout());
		String parent = relativePath.substring(0,
				relativePath.indexOf("children") - 1);
		String child = relativePath.substring(relativePath.indexOf("children"));
		String[] arrayParent = parent.split("\\.");
		String[] arrayChild = child.split("\\.");
		for (int i = 0; i < arrayParent.length; i++) {
			if (node != null) {
				node = node.getParent();
			}
		}

		for (int j = 0; j < arrayChild.length; j++) {
			int childNum = Integer.parseInt(arrayChild[j].substring(9, 10));
			if (node != null) {
				node = node.getChild(childNum);
			}
		}

		if (node == null) {
			Log.d("UiObject",
					"child node is null,please check the relativePath");
			return "false,child node is null,please check the relativePath";
		}

		String retVal = safeStringReturn(node.getText());
		Log.d(LOG_TAG, String.format("getTextByRelativePath() = %s", retVal));
		return retVal;
	}

	/**
	 * 杈撳叆鏂囨湰
	 * 
	 * @param text
	 *            :瑕佽緭鍏ョ殑鏂囨湰
	 * @author n00221817
	 * @return
	 */
	public boolean setTextNonClear(String text)
			throws UiObjectNotFoundException {
		Tracer.trace(text);
		return getInteractionController().sendText(text);
	}

	/**
	 * 设置是否进行等待页面刷新完成
	 * 
	 * @param isWaitForidle
	 */
	public void setWaitForidle(boolean isWaitForidle) {
		getQueryController().setWaitForidle(isWaitForidle);
	}

	/**
	 * 设置查找控件超时时间
	 * 
	 * @author zWX235140 2016/4/15
	 * @param timeout
	 */
	public void setWaitForSelectorTimeout(long timeout) {
		mConfig.setWaitForSelectorTimeout(timeout);
	}

	public boolean clickWidget(AccessibilityNodeInfo node, String type,
			int downtime, int timeout, boolean isSync) {
		Rect rect = getVisibleBounds(node);
		if (!isSync) {
			return getInteractionController().clickNoSync(rect.centerX(),
					rect.centerY(), type, downtime);
		} else {
			return getInteractionController().clickAndSync(rect.centerX(),
					rect.centerY(), type, downtime, timeout);
		}
	}

	public boolean swipe(AccessibilityNodeInfo src, AccessibilityNodeInfo dest,
			int steps, long downTime, long waitTime, boolean drag) {
		Rect rectSrc = getVisibleBounds(src);
		Rect rectDest = getVisibleBounds(dest);
		return getInteractionController().swipe(rectSrc.centerX(),
				rectSrc.centerY(), rectDest.centerX(), rectDest.centerY(),
				steps, drag, downTime, waitTime);
	}

	/**
	 * Finds a matching UI element in the accessibility hierarchy, by using the
	 * selector for this UiObject.
	 * 
	 * @param timeout
	 *            in milliseconds
	 * @return AccessibilityNodeInfo if found else null
	 * @since API Level 16
	 */
	public AccessibilityNodeInfo findNodeInfo(long timeout) {
		AccessibilityNodeInfo node = null;
		long startMills = SystemClock.uptimeMillis();
		Log.d(LOG_TAG, "startMills:" + startMills);
		long currentMills = 0;
		while (currentMills <= timeout) {
			node = getQueryController().findNodeInfo(mSelector);
			if (node != null) {
				break;
			} else {
				// does nothing if we're reentering another runWatchers()
				UiDevice.getInstance().runWatchers();
				Log.d(LOG_TAG,
						"Traversal search node failed to find the target node");
			}

			currentMills = SystemClock.uptimeMillis() - startMills;
			if (timeout > 0) {
				SystemClock.sleep(WAIT_FOR_SELECTOR_POLL);
			}
			Log.d(LOG_TAG, "currentMills:" + currentMills);
		}

		return node;
	}

	/**
	 * 进行压感按压
	 * 
	 * @param node
	 *            目标控件节点
	 * @param forceTouch
	 *            是否重压(二级按压);false时仅一级按压
	 * @param sysPressure
	 *            系统默认压力值
	 * @return
	 * @throws UiObjectNotFoundException
	 */
	public boolean touchPressure(AccessibilityNodeInfo node,
			boolean forceTouch, float sysPressure)
			throws UiObjectNotFoundException {
		Tracer.trace();
		// AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
		// .getWaitForSelectorTimeout());
		// if (node == null) {
		// throw new UiObjectNotFoundException(mSelector.toString());
		// }
		Rect rect = getVisibleBounds(node);
		return getInteractionController().touchPress(rect.centerX(),
				rect.centerY(), forceTouch, sysPressure);
	}

	// ***********************************为自动录制aok定制增加 zwx235140
	// 20161219*****************

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject.
	 * 
	 * @return true id successful else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean clickNode(AccessibilityNodeInfo node) {
		Tracer.trace();
		if (node == null) {
			return false;
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController().clickAndSync(rect.centerX(),
				rect.centerY(), mConfig.getActionAcknowledgmentTimeout());
	}

	/**
	 * Performs a click at the center of the visible bounds of the UI element
	 * represented by this UiObject.
	 * 
	 * @return true id successful else false
	 * @throws UiObjectNotFoundException
	 * @since API Level 16
	 */
	public boolean setFocus(AccessibilityNodeInfo node) {
		Tracer.trace();
		if (node == null) {
			return false;
		}
		Rect rect = getVisibleBounds(node);
		return getInteractionController()
		.longTapNoSync(rect.left + 20, rect.centerY(),1000);
//		return getInteractionController().clickAndSync(rect.left + 20,
//				rect.centerY(), mConfig.getActionAcknowledgmentTimeout());
	}


	public boolean setText(AccessibilityNodeInfo node, String text)
			throws UiObjectNotFoundException {
		Tracer.trace(text);
		clearTextField(node);
		return getInteractionController().sendText(text);
	}

	public void clearTextField(AccessibilityNodeInfo node)
			throws UiObjectNotFoundException {
		Tracer.trace();
		// long click left + center
		// AccessibilityNodeInfo node = findAccessibilityNodeInfo(mConfig
		// .getWaitForSelectorTimeout());
		// if (node == null) {
		// throw new UiObjectNotFoundException(getSelector().toString());
		// }
		Rect rect = getVisibleBounds(node);
		getInteractionController()
				.longTapNoSync(rect.left + 20, rect.centerY(),1000);
		// check if the edit menu is open
//		UiObject selectAll = new UiObject(
//				new UiSelector().descriptionContains("Select all"));
//		if (selectAll.waitForExists(50)){
//			selectAll.click();
//			Log.i(LOG_TAG, "select all");
//		}
		// wait for the selection
//		SystemClock.sleep(250);
		// delete it
//		getInteractionController().sendKey(KeyEvent.KEYCODE_DEL, 0);
	}

	public Boolean swipe(AccessibilityNodeInfo src, AccessibilityNodeInfo dest,
			int steps) {
		Rect rectSrc = getVisibleBounds(src);
		Rect rectDest = getVisibleBounds(dest);
		if ((rectSrc.centerX() == rectDest.centerX())
				&& (rectSrc.centerY() == rectDest.centerY())) {
			Log.i(LOG_TAG, "前后坐标相等，不需要滑动");
			return false;
		}
		return getInteractionController().scrollSwipe(rectSrc.centerX(),
				rectSrc.centerY(), rectDest.centerX(), rectDest.centerY(),
				steps);

	}
}
